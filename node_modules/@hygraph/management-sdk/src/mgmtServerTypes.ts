export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  JSON: any;
  DateTime: any;
};

export type IAssetConfig = {
  apiKey: Scalars['String'];
};

export type FilestackSecurityOptions = {
  __typename?: 'FilestackSecurityOptions';
  enabled: Scalars['Boolean'];
  auth?: Maybe<FilestackSecurityAuthOptions>;
  globalExpires: Scalars['String'];
  stageOverrides: Array<StageFilestackSecurityOptions>;
};

export type FilestackSecurityAuthOptions = {
  __typename?: 'FilestackSecurityAuthOptions';
  policy: Scalars['String'];
  signature: Scalars['String'];
};

export type StageFilestackSecurityOptions = {
  __typename?: 'StageFilestackSecurityOptions';
  stage: Stage;
  expires: Scalars['String'];
};

export type Filestack = IAssetConfig & {
  __typename?: 'Filestack';
  apiKey: Scalars['String'];
  path: Scalars['String'];
  bucket: Scalars['String'];
  isManagedBucket: Scalars['Boolean'];
  security: FilestackSecurityOptions;
};

export type AssetSystem = IAssetConfig & {
  __typename?: 'AssetSystem';
  apiKey: Scalars['String'];
};

export type ContentModel = {
  __typename?: 'ContentModel';
  models: Array<IModel>;
  model: IModel;
  components: Array<Component>;
  component: Component;
  assetModel: IModel;
  enumerations: Array<Enumeration>;
  enumeration: Enumeration;
  locales: Array<Locale>;
  unions: Array<Maybe<Union>>;
  stages: Array<Stage>;
  field: IField;
};


export type ContentModelModelsArgs = {
  includeSystemModels?: InputMaybe<Scalars['Boolean']>;
};


export type ContentModelModelArgs = {
  id?: InputMaybe<Scalars['ID']>;
  apiId?: InputMaybe<Scalars['String']>;
};


export type ContentModelComponentsArgs = {
  includeSystemComponents?: InputMaybe<Scalars['Boolean']>;
};


export type ContentModelComponentArgs = {
  id?: InputMaybe<Scalars['ID']>;
  apiId?: InputMaybe<Scalars['String']>;
};


export type ContentModelEnumerationsArgs = {
  includeSystemEnumerations?: InputMaybe<Scalars['Boolean']>;
};


export type ContentModelEnumerationArgs = {
  id?: InputMaybe<Scalars['ID']>;
  apiId?: InputMaybe<Scalars['String']>;
};


export type ContentModelFieldArgs = {
  id: Scalars['ID'];
};

export enum ContentViewType {
  BuiltIn = 'BUILT_IN',
  Public = 'PUBLIC'
}

export enum ColumnOrderByDir {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type OrderBy = {
  __typename?: 'OrderBy';
  orderByField: IField;
  orderDir: ColumnOrderByDir;
};

export type ContentView = {
  __typename?: 'ContentView';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  model: IModel;
  type: ContentViewType;
  isSystem: Scalars['Boolean'];
  orderBy?: Maybe<OrderBy>;
  /** @deprecated Use allColumns instead */
  columns: Array<ContentViewColumn>;
  allColumns: Array<IContentViewColumn>;
  viewGroup: ViewGroup;
  position?: Maybe<Scalars['Int']>;
  filters: Scalars['JSON'];
};

export type ContentViewColumn = {
  __typename?: 'ContentViewColumn';
  id: Scalars['ID'];
  isVisible: Scalars['Boolean'];
  width?: Maybe<Scalars['Int']>;
  position: Scalars['Int'];
  field: IField;
};

export type IContentViewColumn = {
  id: Scalars['ID'];
  isVisible: Scalars['Boolean'];
  width?: Maybe<Scalars['Int']>;
  position: Scalars['Int'];
  type: ContentViewColumnType;
};

export type ContentViewFieldColumn = IContentViewColumn & {
  __typename?: 'ContentViewFieldColumn';
  id: Scalars['ID'];
  isVisible: Scalars['Boolean'];
  width?: Maybe<Scalars['Int']>;
  position: Scalars['Int'];
  type: ContentViewColumnType;
  field: IField;
};

export type ContentViewSystemColumn = IContentViewColumn & {
  __typename?: 'ContentViewSystemColumn';
  id: Scalars['ID'];
  isVisible: Scalars['Boolean'];
  width?: Maybe<Scalars['Int']>;
  position: Scalars['Int'];
  type: ContentViewColumnType;
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
};

export type ContentViewFilterInput = {
  skip?: InputMaybe<Scalars['Int']>;
  limit?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
  /**
   * Only include content views when the current viewer has access to the content of the connected model
   * Conditional access is treated as having access. This does only work on UseViewer (PATs are not supported).
   * This filter checks for READ access on the DRAFT stage only.
   */
  viewerHasContentPermissions?: Scalars['Boolean'];
};

export enum ContentViewColumnType {
  Field = 'FIELD',
  Stages = 'STAGES'
}

export type Stats = {
  __typename?: 'Stats';
  time: Scalars['DateTime'];
  value: Scalars['Float'];
};

export type Metrics = {
  __typename?: 'Metrics';
  apiOperations: Array<Stats>;
  assetTraffic: Array<Stats>;
  assetTransformations: Array<Stats>;
};


export type MetricsApiOperationsArgs = {
  start: Scalars['DateTime'];
  end: Scalars['DateTime'];
  resolution: Scalars['Int'];
};


export type MetricsAssetTrafficArgs = {
  start: Scalars['DateTime'];
  end: Scalars['DateTime'];
};


export type MetricsAssetTransformationsArgs = {
  start: Scalars['DateTime'];
  end: Scalars['DateTime'];
};

export type PermanentAuthToken = {
  __typename?: 'PermanentAuthToken';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  token: Scalars['String'];
  defaults: PermanentAuthTokenDefaults;
  contentPermissions: Array<IContentPermission>;
  managementPermissions: Array<ManagementPermission>;
};

export type PermanentAuthTokenDefaults = {
  __typename?: 'PermanentAuthTokenDefaults';
  stage: Stage;
};

export type AppToken = {
  __typename?: 'AppToken';
  id: Scalars['ID'];
  app: App;
};

export type ManagementPermission = {
  __typename?: 'ManagementPermission';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  description?: Maybe<Scalars['String']>;
  action: PermissionAction;
};

export enum PermissionAction {
  ProjectClone = 'PROJECT_CLONE',
  ProjectUpdate = 'PROJECT_UPDATE',
  ProjectDelete = 'PROJECT_DELETE',
  ManagePayment = 'MANAGE_PAYMENT',
  PlaygroundUse = 'PLAYGROUND_USE',
  AuditLogsRead = 'AUDIT_LOGS_READ',
  ViewTeamMemberSettings = 'VIEW_TEAM_MEMBER_SETTINGS',
  ViewRolePermissionSettings = 'VIEW_ROLE_PERMISSION_SETTINGS',
  ViewSchema = 'VIEW_SCHEMA',
  EnvironmentCreate = 'ENVIRONMENT_CREATE',
  EnvironmentRead = 'ENVIRONMENT_READ',
  EnvironmentUpdate = 'ENVIRONMENT_UPDATE',
  EnvironmentDelete = 'ENVIRONMENT_DELETE',
  EnvironmentPromote = 'ENVIRONMENT_PROMOTE',
  EnvironmentBackupCreate = 'ENVIRONMENT_BACKUP_CREATE',
  EnvironmentBackupRead = 'ENVIRONMENT_BACKUP_READ',
  EnvironmentBackupUpdate = 'ENVIRONMENT_BACKUP_UPDATE',
  EnvironmentBackupDelete = 'ENVIRONMENT_BACKUP_DELETE',
  EnvironmentBackupRestore = 'ENVIRONMENT_BACKUP_RESTORE',
  ModelCreate = 'MODEL_CREATE',
  ModelRead = 'MODEL_READ',
  ModelUpdate = 'MODEL_UPDATE',
  ModelDelete = 'MODEL_DELETE',
  ComponentCreate = 'COMPONENT_CREATE',
  ComponentRead = 'COMPONENT_READ',
  ComponentUpdate = 'COMPONENT_UPDATE',
  ComponentDelete = 'COMPONENT_DELETE',
  LocaleCreate = 'LOCALE_CREATE',
  LocaleRead = 'LOCALE_READ',
  LocaleUpdate = 'LOCALE_UPDATE',
  LocaleDelete = 'LOCALE_DELETE',
  StageCreate = 'STAGE_CREATE',
  StageRead = 'STAGE_READ',
  StageUpdate = 'STAGE_UPDATE',
  StageDelete = 'STAGE_DELETE',
  EnumerationCreate = 'ENUMERATION_CREATE',
  EnumerationRead = 'ENUMERATION_READ',
  EnumerationUpdate = 'ENUMERATION_UPDATE',
  EnumerationDelete = 'ENUMERATION_DELETE',
  FieldCreate = 'FIELD_CREATE',
  FieldRead = 'FIELD_READ',
  FieldUpdate = 'FIELD_UPDATE',
  FieldDelete = 'FIELD_DELETE',
  RemoteSourceCreate = 'REMOTE_SOURCE_CREATE',
  RemoteSourceRead = 'REMOTE_SOURCE_READ',
  RemoteSourceUpdate = 'REMOTE_SOURCE_UPDATE',
  RemoteSourceDelete = 'REMOTE_SOURCE_DELETE',
  PatCreate = 'PAT_CREATE',
  PatRead = 'PAT_READ',
  PatUpdate = 'PAT_UPDATE',
  PatDelete = 'PAT_DELETE',
  ContentviewCreate = 'CONTENTVIEW_CREATE',
  ContentviewRead = 'CONTENTVIEW_READ',
  ContentviewUpdate = 'CONTENTVIEW_UPDATE',
  ContentviewSystemUpdate = 'CONTENTVIEW_SYSTEM_UPDATE',
  ContentviewDelete = 'CONTENTVIEW_DELETE',
  StorageBucketCreate = 'STORAGE_BUCKET_CREATE',
  StorageBucketRead = 'STORAGE_BUCKET_READ',
  StorageBucketUpdate = 'STORAGE_BUCKET_UPDATE',
  StorageBucketDelete = 'STORAGE_BUCKET_DELETE',
  RoleCreate = 'ROLE_CREATE',
  RoleUpdate = 'ROLE_UPDATE',
  RoleDelete = 'ROLE_DELETE',
  WebhookCreate = 'WEBHOOK_CREATE',
  WebhookRead = 'WEBHOOK_READ',
  WebhookUpdate = 'WEBHOOK_UPDATE',
  WebhookDelete = 'WEBHOOK_DELETE',
  UserInvite = 'USER_INVITE',
  UserAssignrole = 'USER_ASSIGNROLE',
  UserRemove = 'USER_REMOVE',
  ViewGroupCreate = 'VIEW_GROUP_CREATE',
  ViewGroupRead = 'VIEW_GROUP_READ',
  ViewGroupUpdate = 'VIEW_GROUP_UPDATE',
  ViewGroupDelete = 'VIEW_GROUP_DELETE',
  ContentCreate = 'CONTENT_CREATE',
  ContentRead = 'CONTENT_READ',
  ContentUpdate = 'CONTENT_UPDATE',
  ContentDelete = 'CONTENT_DELETE',
  ContentPublish = 'CONTENT_PUBLISH',
  ContentUpdatePublished = 'CONTENT_UPDATE_PUBLISHED',
  ContentPermissionCreate = 'CONTENT_PERMISSION_CREATE',
  ContentPermissionRead = 'CONTENT_PERMISSION_READ',
  ContentPermissionUpdate = 'CONTENT_PERMISSION_UPDATE',
  ContentPermissionDelete = 'CONTENT_PERMISSION_DELETE',
  IntegrationCreate = 'INTEGRATION_CREATE',
  IntegrationRead = 'INTEGRATION_READ',
  IntegrationUpdate = 'INTEGRATION_UPDATE',
  IntegrationDelete = 'INTEGRATION_DELETE',
  NetlifyTriggerBuild = 'NETLIFY_TRIGGER_BUILD',
  ExtensionCreate = 'EXTENSION_CREATE',
  ExtensionRead = 'EXTENSION_READ',
  ExtensionUpdate = 'EXTENSION_UPDATE',
  ExtensionDelete = 'EXTENSION_DELETE',
  AppCreate = 'APP_CREATE',
  AppUpdate = 'APP_UPDATE',
  AppDelete = 'APP_DELETE',
  AppInstallationCreate = 'APP_INSTALLATION_CREATE',
  AppInstallationUpdate = 'APP_INSTALLATION_UPDATE',
  AppInstallationDelete = 'APP_INSTALLATION_DELETE'
}

export type MembersAggregate = {
  __typename?: 'MembersAggregate';
  count: Scalars['Int'];
};

export type PageInfo = {
  __typename?: 'PageInfo';
  hasNextPage: Scalars['Boolean'];
  hasPreviousPage: Scalars['Boolean'];
  pageSize: Scalars['Int'];
};

export type MembersConnection = {
  __typename?: 'MembersConnection';
  pageInfo: PageInfo;
  edges: Array<MemberEdge>;
  aggregate: MembersAggregate;
};

export type MemberEdge = {
  __typename?: 'MemberEdge';
  node: Member;
};

export type Progress = {
  __typename?: 'Progress';
  current: Scalars['Float'];
  max?: Maybe<Scalars['Float']>;
  percent?: Maybe<Scalars['Float']>;
  estimate?: Maybe<Scalars['Float']>;
};

export type EnvironmentLevelQuota = {
  __typename?: 'EnvironmentLevelQuota';
  locales: Progress;
  webhooks: Progress;
  models: Progress;
  stages: Progress;
  contentPermissions: Progress;
  remoteSources: Progress;
  components: Progress;
};

export type Role = {
  __typename?: 'Role';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  isDefault: Scalars['Boolean'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  /**
   * Returns contentPermissions for a role.
   * Optionally filtered by environment.
   */
  contentPermissions: Array<IContentPermission>;
  managementPermissions: Array<ManagementPermission>;
  members: Array<Member>;
  membersConnection: MembersConnection;
};


export type RoleContentPermissionsArgs = {
  environmentId?: InputMaybe<Scalars['ID']>;
};


export type RoleMembersConnectionArgs = {
  skip?: Scalars['Int'];
  first?: Scalars['Int'];
};

export type ContentPermissionRoleTarget = {
  __typename?: 'ContentPermissionRoleTarget';
  role: Role;
  environment: Environment;
};

export type ContentPermissionPermanentAuthTokenTarget = {
  __typename?: 'ContentPermissionPermanentAuthTokenTarget';
  permanentAuthToken: PermanentAuthToken;
};

export type ContentPermissionAppTokenTarget = {
  __typename?: 'ContentPermissionAppTokenTarget';
  appInstallation?: Maybe<AppInstallation>;
};

export type ContentPermissionPublicTarget = {
  __typename?: 'ContentPermissionPublicTarget';
  environment: Environment;
};

export type ContentPermissionTarget = ContentPermissionRoleTarget | ContentPermissionPermanentAuthTokenTarget | ContentPermissionPublicTarget | ContentPermissionAppTokenTarget;

export type IContentPermission = {
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  enabled: Scalars['Boolean'];
  target: ContentPermissionTarget;
  model?: Maybe<IModel>;
};

export type ReadContentPermission = IContentPermission & {
  __typename?: 'ReadContentPermission';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  enabled: Scalars['Boolean'];
  target: ContentPermissionTarget;
  model?: Maybe<IModel>;
  locales?: Maybe<Array<Locale>>;
  stages?: Maybe<Array<Stage>>;
  condition?: Maybe<Scalars['String']>;
};

export type ReadVersionContentPermission = IContentPermission & {
  __typename?: 'ReadVersionContentPermission';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  enabled: Scalars['Boolean'];
  target: ContentPermissionTarget;
  model?: Maybe<IModel>;
};

export type CreateContentPermission = IContentPermission & {
  __typename?: 'CreateContentPermission';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  enabled: Scalars['Boolean'];
  target: ContentPermissionTarget;
  model?: Maybe<IModel>;
  locales?: Maybe<Array<Locale>>;
  condition?: Maybe<Scalars['String']>;
};

export type UpdateContentPermission = IContentPermission & {
  __typename?: 'UpdateContentPermission';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  enabled: Scalars['Boolean'];
  target: ContentPermissionTarget;
  model?: Maybe<IModel>;
  locales?: Maybe<Array<Locale>>;
  condition?: Maybe<Scalars['String']>;
};

export type DeleteContentPermission = IContentPermission & {
  __typename?: 'DeleteContentPermission';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  enabled: Scalars['Boolean'];
  target: ContentPermissionTarget;
  model?: Maybe<IModel>;
  locales?: Maybe<Array<Locale>>;
  condition?: Maybe<Scalars['String']>;
};

export type PublishContentPermission = IContentPermission & {
  __typename?: 'PublishContentPermission';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  enabled: Scalars['Boolean'];
  target: ContentPermissionTarget;
  model?: Maybe<IModel>;
  locales?: Maybe<Array<Locale>>;
  fromStages?: Maybe<Array<Stage>>;
  toStages?: Maybe<Array<Stage>>;
  condition?: Maybe<Scalars['String']>;
};

export type UnpublishContentPermission = IContentPermission & {
  __typename?: 'UnpublishContentPermission';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  enabled: Scalars['Boolean'];
  target: ContentPermissionTarget;
  model?: Maybe<IModel>;
  locales?: Maybe<Array<Locale>>;
  stages?: Maybe<Array<Stage>>;
  condition?: Maybe<Scalars['String']>;
};

export enum MigrationStatus {
  Queued = 'QUEUED',
  Running = 'RUNNING',
  Success = 'SUCCESS',
  Timeout = 'TIMEOUT',
  Failed = 'FAILED'
}

export type Migration = {
  __typename?: 'Migration';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  finishedAt?: Maybe<Scalars['DateTime']>;
  /** @deprecated This will be replaced by a union of Member | PermanentAuthToken */
  triggeredBy?: Maybe<Member>;
  status: MigrationStatus;
  errors?: Maybe<Scalars['String']>;
  /** @deprecated Field no longer supported */
  operationType: MigrationOperationType;
  /** @deprecated Field no longer supported */
  resourceId?: Maybe<Scalars['ID']>;
  /** Name of the migration in case if was triggered via a named batch migration */
  name?: Maybe<Scalars['String']>;
};

export enum Remote_Graphql_Type {
  Scalar = 'SCALAR',
  Object = 'OBJECT',
  Interface = 'INTERFACE',
  Union = 'UNION',
  Enum = 'ENUM',
  InputObject = 'INPUT_OBJECT'
}

export type IRemoteSource = {
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  prefix: Scalars['String'];
  url: Scalars['String'];
  /**
   * Optional headers that will be sent to the remote source on every remote field. In case the remote field is using the same
   * Header Keys, the values will be overridden
   */
  headers?: Maybe<Scalars['JSON']>;
  type: RemoteSourceType;
  remoteTypeDefinitionsConnection: RemoteTypeDefinitionsConnection;
  debugEnabled: Scalars['Boolean'];
  kind?: Maybe<RemoteSourceKind>;
  oAuth?: Maybe<Scalars['JSON']>;
};


export type IRemoteSourceRemoteTypeDefinitionsConnectionArgs = {
  remoteGraphQLTypes?: InputMaybe<Array<Remote_Graphql_Type>>;
  isUserDefined?: InputMaybe<Scalars['Boolean']>;
  skip?: Scalars['Int'];
  first?: Scalars['Int'];
};

export type GraphQlRemoteSource = IRemoteSource & IRecentSchemaChange & {
  __typename?: 'GraphQLRemoteSource';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  prefix: Scalars['String'];
  url: Scalars['String'];
  headers?: Maybe<Scalars['JSON']>;
  type: RemoteSourceType;
  remoteTypeDefinitionsConnection: RemoteTypeDefinitionsConnection;
  debugEnabled: Scalars['Boolean'];
  kind?: Maybe<RemoteSourceKind>;
  /**
   * Specific URL that will be used for introspection if the introspection is available on another url than the regular url.
   * Can be ignored if the introspection url is the same as the url of the remote source.
   */
  introspectionUrl?: Maybe<Scalars['String']>;
  /** HTTP Headers that will be used when sending the introspection only */
  introspectionHeaders?: Maybe<Scalars['JSON']>;
  /** HTTP method that will be used for introspection */
  introspectionMethod: GraphQlRemoteSourceIntrospectionMethod;
  schema: Scalars['String'];
  oAuth?: Maybe<Scalars['JSON']>;
};


export type GraphQlRemoteSourceRemoteTypeDefinitionsConnectionArgs = {
  remoteGraphQLTypes?: InputMaybe<Array<Remote_Graphql_Type>>;
  isUserDefined?: InputMaybe<Scalars['Boolean']>;
  skip?: Scalars['Int'];
  first?: Scalars['Int'];
};

export type RestRemoteSource = IRemoteSource & IRecentSchemaChange & {
  __typename?: 'RESTRemoteSource';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  prefix: Scalars['String'];
  url: Scalars['String'];
  headers?: Maybe<Scalars['JSON']>;
  type: RemoteSourceType;
  remoteTypeDefinitionsConnection: RemoteTypeDefinitionsConnection;
  debugEnabled: Scalars['Boolean'];
  kind?: Maybe<RemoteSourceKind>;
  oAuth?: Maybe<Scalars['JSON']>;
};


export type RestRemoteSourceRemoteTypeDefinitionsConnectionArgs = {
  remoteGraphQLTypes?: InputMaybe<Array<Remote_Graphql_Type>>;
  isUserDefined?: InputMaybe<Scalars['Boolean']>;
  skip?: Scalars['Int'];
  first?: Scalars['Int'];
};

export type RemoteTypeDefinitionEdge = {
  __typename?: 'RemoteTypeDefinitionEdge';
  node: RemoteTypeDefinition;
};

export type RemoteTypeDefinitionsAggregate = {
  __typename?: 'RemoteTypeDefinitionsAggregate';
  count: Scalars['Int'];
};

export type RemoteTypeDefinitionsConnection = {
  __typename?: 'RemoteTypeDefinitionsConnection';
  pageInfo: PageInfo;
  edges: Array<RemoteTypeDefinitionEdge>;
  aggregate: RemoteTypeDefinitionsAggregate;
};

export type CommentingConfig = {
  __typename?: 'CommentingConfig';
  url: Scalars['String'];
  token: Scalars['String'];
  userKey: Scalars['String'];
};

export type Environment = {
  __typename?: 'Environment';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  name: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  endpoint: Scalars['String'];
  deliveryUrl?: Maybe<Scalars['String']>;
  newDeliveryUrl: Scalars['String'];
  assetConfig: IAssetConfig;
  metrics: Metrics;
  webhook: Webhook;
  webhooks: Array<Webhook>;
  permanentAuthTokens: Array<PermanentAuthToken>;
  authToken: Scalars['String'];
  contentView: ContentView;
  contentViews: Array<ContentView>;
  viewGroups: Array<ViewGroup>;
  contentModel: ContentModel;
  remoteSources: Array<IRemoteSource>;
  remoteSource: IRemoteSource;
  /** @deprecated Revisions are no longer maintained */
  revisionCount: Scalars['Int'];
  migrations: Array<Migration>;
  migration: Migration;
  runningMigration?: Maybe<Migration>;
  publicContentAPI: PublicContentApi;
  isCloning?: Maybe<Scalars['Boolean']>;
  quotas: EnvironmentLevelQuota;
  integrations: Array<IIntegration>;
  integration: IIntegration;
  extensions: Array<IExtension>;
  extension: IExtension;
  appInstallations: Array<AppInstallation>;
  appInstallation: AppInstallation;
  diff: DiffEnvironmentPayload;
  commentingConfig?: Maybe<CommentingConfig>;
  recentSchemaChanges: Array<IRecentSchemaChange>;
  color?: Maybe<ColorPalette>;
};


export type EnvironmentWebhookArgs = {
  id: Scalars['ID'];
};


export type EnvironmentContentViewArgs = {
  id: Scalars['ID'];
};


export type EnvironmentContentViewsArgs = {
  includeSystemModels?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<ContentViewFilterInput>;
};


export type EnvironmentRemoteSourceArgs = {
  prefix: Scalars['String'];
};


export type EnvironmentMigrationArgs = {
  id?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
};


export type EnvironmentIntegrationArgs = {
  id: Scalars['ID'];
};


export type EnvironmentExtensionArgs = {
  id: Scalars['ID'];
};


export type EnvironmentAppInstallationsArgs = {
  status?: InputMaybe<AppInstallationStatus>;
};


export type EnvironmentAppInstallationArgs = {
  appApiId: Scalars['String'];
};


export type EnvironmentDiffArgs = {
  environmentName: Scalars['String'];
};


export type EnvironmentRecentSchemaChangesArgs = {
  limit?: Scalars['Int'];
};

export type IRecentSchemaChange = {
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
};

export type PublicContentApiDefauts = {
  __typename?: 'PublicContentAPIDefauts';
  stage: Stage;
};

export type PublicContentApi = {
  __typename?: 'PublicContentAPI';
  defaults: PublicContentApiDefauts;
  contentPermissions: Array<IContentPermission>;
};

export type IIntegration = {
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  displayName?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
};

export type NetlifyIntegration = IIntegration & {
  __typename?: 'NetlifyIntegration';
  /** Integration ID */
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  /** Integration display name on GCMS */
  displayName?: Maybe<Scalars['String']>;
  /** Integration description on GCMS */
  description?: Maybe<Scalars['String']>;
  /** Configured sites for netlify integration */
  sites: Array<NetlifySite>;
  models: Array<IModel>;
};

export type GatsbyCloudIntegration = IIntegration & {
  __typename?: 'GatsbyCloudIntegration';
  /** Integration ID */
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  /** Integration display name on GCMS */
  displayName?: Maybe<Scalars['String']>;
  /** Integration description on GCMS */
  description?: Maybe<Scalars['String']>;
  /** URL to your site */
  siteURL: Scalars['String'];
  /** Prefix of your site */
  sitePrefix: Scalars['String'];
  /** URL to the preview of your site */
  previewURL: Scalars['String'];
  /** URL to the production deployment of your site */
  productionURL: Scalars['String'];
  /** URL to trigger a Deploy Build. This webhook will be triggered when publishing and unpublishing entries. */
  buildWebhookURL: Scalars['String'];
  /** URL to trigger a CMS Preview build */
  previewWebhookURL: Scalars['String'];
};

export type NetlifySite = {
  __typename?: 'NetlifySite';
  id: Scalars['String'];
  displayName: Scalars['String'];
  url: Scalars['String'];
  /** Contains information of the last time the build state was changing. */
  lastState?: Maybe<NetlifyState>;
};

export type NetlifyState = {
  __typename?: 'NetlifyState';
  /** Current state the site is in */
  buildState: NetlifyBuildState;
  /** Time when the build of the site was started */
  buildStartedAt?: Maybe<Scalars['DateTime']>;
  /** Time when the build of the site was prepared */
  buildPreparedAt?: Maybe<Scalars['DateTime']>;
  /** Time when the build of the site was finished */
  buildFinishedAt?: Maybe<Scalars['DateTime']>;
  /** Member in the project who triggered a build. If the build was triggered externally this will be null. */
  triggeredBy?: Maybe<NetlifyStateTriggeredBy>;
};

export type NetlifyStateTriggeredBy = PermanentAuthToken | Member;

export enum ColorPalette {
  Purple = 'PURPLE',
  Teal = 'TEAL',
  Yellow = 'YELLOW',
  Green = 'GREEN',
  Blue = 'BLUE',
  Red = 'RED',
  Pink = 'PINK',
  Brown = 'BROWN',
  Orange = 'ORANGE',
  Indigo = 'INDIGO',
  Olive = 'OLIVE',
  Rose = 'ROSE',
  Neutral = 'NEUTRAL'
}

export type Stage = {
  __typename?: 'Stage';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  apiId: Scalars['String'];
  color: Scalars['String'];
  colorPaletteId: ColorPalette;
  backgroundColor: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  isSystem: Scalars['Boolean'];
  position: Scalars['Int'];
};

export type Profile = {
  __typename?: 'Profile';
  id: Scalars['ID'];
  email: Scalars['String'];
  name: Scalars['String'];
  picture?: Maybe<Scalars['String']>;
  role?: Maybe<Scalars['String']>;
  purpose?: Maybe<Scalars['String']>;
  companyName?: Maybe<Scalars['String']>;
  companySize?: Maybe<Scalars['String']>;
};

export type IUser = {
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  profile: Profile;
  preferences?: Maybe<Scalars['JSON']>;
};

export type MemberHasPermissionsPayload = {
  __typename?: 'MemberHasPermissionsPayload';
  notAllowedActions: Array<PermissionAction>;
};

export type Member = IUser & {
  __typename?: 'Member';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  profile: Profile;
  preferences?: Maybe<Scalars['JSON']>;
  userSelection: UserSelection;
  roles: Array<Role>;
  isOwner: Scalars['Boolean'];
  hasPermissions: MemberHasPermissionsPayload;
};


export type MemberHasPermissionsArgs = {
  actions: Array<PermissionAction>;
};

export enum ViewGroupType {
  Custom = 'CUSTOM',
  System = 'SYSTEM',
  UserCreated = 'USER_CREATED'
}

export enum ViewGroupContentType {
  Default = 'DEFAULT',
  Asset = 'ASSET'
}

export type ViewGroup = {
  __typename?: 'ViewGroup';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  environment: Environment;
  type: ViewGroupType;
  contentType: ViewGroupContentType;
  position: Scalars['Int'];
  createdBy?: Maybe<Member>;
  contentViews: Array<ContentView>;
};


export type ViewGroupContentViewsArgs = {
  filter?: InputMaybe<ContentViewFilterInput>;
};

export type Webhook = {
  __typename?: 'Webhook';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  url: Scalars['String'];
  method: WebhookMethod;
  headers: Scalars['JSON'];
  isActive: Scalars['Boolean'];
  environment: Environment;
  /**
   * List of models on which the webhook will be triggered.
   * In case of any model, this array will be empty.
   */
  models: Array<IModel>;
  /**
   * List of stages on which the webhook will be triggered.
   * In case of any stage, this array will be empty.
   */
  stages: Array<Stage>;
  /** The type of trigger the webhook is registered */
  triggerType: WebhookTriggerType;
  /** When one of the actions happen, the webhook will be triggered */
  triggerActions: Array<WebhookTriggerAction>;
  /**
   * Defines wether the data of the changed data will be sent
   * in the webhook payload or not
   */
  includePayload: Scalars['Boolean'];
  hasSecretKey?: Maybe<Scalars['Boolean']>;
  logs: WebhookLogsPayload;
  log?: Maybe<WebhookLog>;
  triggerSources?: Maybe<Array<WebhookTriggerSource>>;
  createdBy?: Maybe<CreatedBy>;
  isSystem: Scalars['Boolean'];
};


export type WebhookLogsArgs = {
  where?: InputMaybe<WebhookLogsWhereInput>;
  limit?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  after?: InputMaybe<Scalars['String']>;
  orderBy?: InputMaybe<WebhookLogOrderByInput>;
};


export type WebhookLogArgs = {
  id: Scalars['String'];
};

export enum WebhookTriggerSource {
  Pat = 'PAT',
  Member = 'MEMBER',
  Public = 'PUBLIC'
}

export type WebhookLogsPayload = {
  __typename?: 'WebhookLogsPayload';
  total: Scalars['Int'];
  entries: Array<WebhookLog>;
};

export type WebhookLogsWhereInput = {
  action_eq?: InputMaybe<WebhookTriggerAction>;
  modelId_eq?: InputMaybe<Scalars['ID']>;
  status_eq?: InputMaybe<Scalars['Int']>;
  status_in?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  status_gt?: InputMaybe<Scalars['Int']>;
  status_gte?: InputMaybe<Scalars['Int']>;
  status_lt?: InputMaybe<Scalars['Int']>;
  status_lte?: InputMaybe<Scalars['Int']>;
};

export enum WebhookLogOrderByInput {
  CalledAtAsc = 'calledAt_ASC',
  CalledAtDesc = 'calledAt_DESC'
}

export type WebhookLog = {
  __typename?: 'WebhookLog';
  id: Scalars['String'];
  requestPayload?: Maybe<Scalars['JSON']>;
  responsePayload?: Maybe<Scalars['String']>;
  responsePayloadSize?: Maybe<Scalars['Int']>;
  calledAt: Scalars['DateTime'];
  statusCode: Scalars['Int'];
  model?: Maybe<IModel>;
  triggerAction: WebhookTriggerAction;
  attempts: Scalars['Int'];
  duration: Scalars['Float'];
};

/** Defines the type of the trigger */
export enum WebhookTriggerType {
  ContentModel = 'CONTENT_MODEL'
}

/**
 * Defines which operation will trigger the webhook.
 * Some operations rely on the type of stage. E.g. on a
 * publishing stage, the webhook will only be triggered for
 * PUBLISH and UNPUBLISH events. On other stages, only
 * CREATE, UPDATE and DELETE are triggering the webhook.
 */
export enum WebhookTriggerAction {
  Create = 'CREATE',
  Update = 'UPDATE',
  Delete = 'DELETE',
  Publish = 'PUBLISH',
  Unpublish = 'UNPUBLISH'
}

export enum WebhookMethod {
  Get = 'GET',
  Post = 'POST',
  Put = 'PUT',
  Delete = 'DELETE'
}

export enum AvailableExtensionSrcType {
  Inline = 'INLINE',
  Sdk = 'SDK'
}

export enum AvailableExtensionPermissionAction {
  Input = 'INPUT',
  Form = 'FORM',
  Api = 'API'
}

export enum ExtensionFieldType {
  Id = 'ID',
  String = 'STRING',
  Richtext = 'RICHTEXT',
  Int = 'INT',
  Float = 'FLOAT',
  Boolean = 'BOOLEAN',
  Json = 'JSON',
  Datetime = 'DATETIME',
  Date = 'DATE',
  Location = 'LOCATION',
  Color = 'COLOR',
  Graphql = 'GRAPHQL',
  Rest = 'REST',
  Enumeration = 'ENUMERATION',
  Relation = 'RELATION',
  Asset = 'ASSET',
  Union = 'UNION'
}

export type ExtensionSrcType = {
  __typename?: 'ExtensionSrcType';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  description?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  type: AvailableExtensionSrcType;
};

export type AvailableExtensionPermission = {
  __typename?: 'AvailableExtensionPermission';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  description?: Maybe<Scalars['String']>;
  name: AvailableExtensionPermissionAction;
};

export type IExtension = {
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  createdBy?: Maybe<Member>;
  updatedBy?: Maybe<Member>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  apiId: Scalars['String'];
  /** The type indicating where the source for the extension will be obtained from */
  srcType: ExtensionSrcType;
  /** Location for the source if the source type is an external one */
  src: Scalars['String'];
  environment: Environment;
  config: Scalars['JSON'];
  isActive: Scalars['Boolean'];
  meta?: Maybe<Scalars['JSON']>;
  neededPermissions: Array<AvailableExtensionPermission>;
};

export type FieldExtension = IExtension & {
  __typename?: 'FieldExtension';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  createdBy?: Maybe<Member>;
  updatedBy?: Maybe<Member>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  apiId: Scalars['String'];
  /** The type indicating where the source for the extension will be obtained from */
  srcType: ExtensionSrcType;
  /** Location for the source if the source type is an external one */
  src: Scalars['String'];
  environment: Environment;
  config: Scalars['JSON'];
  isActive: Scalars['Boolean'];
  meta?: Maybe<Scalars['JSON']>;
  neededPermissions: Array<AvailableExtensionPermission>;
  fieldType: ExtensionFieldType;
  hasFormRenderer: Scalars['Boolean'];
  hasListRenderer: Scalars['Boolean'];
  hasTableRenderer: Scalars['Boolean'];
  fields: Array<IField>;
};

export type SidebarExtension = IExtension & {
  __typename?: 'SidebarExtension';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  createdBy?: Maybe<Member>;
  updatedBy?: Maybe<Member>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  apiId: Scalars['String'];
  /** The type indicating where the source for the extension will be obtained from */
  srcType: ExtensionSrcType;
  /** Location for the source if the source type is an external one */
  src: Scalars['String'];
  environment: Environment;
  config: Scalars['JSON'];
  isActive: Scalars['Boolean'];
  meta?: Maybe<Scalars['JSON']>;
  neededPermissions: Array<AvailableExtensionPermission>;
  sidebarElements: Array<ISidebarElement>;
};

export enum AppPublicationStatus {
  Private = 'PRIVATE',
  Pending = 'PENDING',
  Public = 'PUBLIC'
}

export enum AppSchemaPermission {
  None = 'NONE',
  Read = 'READ',
  ReadWrite = 'READ_WRITE'
}

export enum AppContentPermission {
  None = 'NONE',
  Read = 'READ',
  ReadWrite = 'READ_WRITE'
}

export enum AppWebhooksPermission {
  None = 'NONE',
  ReadWrite = 'READ_WRITE'
}

export enum AppUserPermission {
  None = 'NONE',
  Read = 'READ'
}

export type AppPermissions = {
  __typename?: 'AppPermissions';
  SCHEMA: AppSchemaPermission;
  CONTENT: AppContentPermission;
  WEBHOOKS: AppWebhooksPermission;
  USER: AppUserPermission;
};

export type IApp = {
  id: Scalars['ID'];
  author: Scalars['ID'];
  name: Scalars['String'];
  apiId: Scalars['String'];
  setupUrl: Scalars['String'];
  webhookUrl?: Maybe<Scalars['String']>;
  configurationUrl?: Maybe<Scalars['String']>;
  elements?: Maybe<Array<IAppElement>>;
  avatarUrl: Scalars['String'];
  description: Scalars['String'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  publicationStatus: AppPublicationStatus;
  permissions: AppPermissions;
};

export type App = IApp & {
  __typename?: 'App';
  id: Scalars['ID'];
  author: Scalars['ID'];
  name: Scalars['String'];
  apiId: Scalars['String'];
  setupUrl: Scalars['String'];
  webhookUrl?: Maybe<Scalars['String']>;
  configurationUrl?: Maybe<Scalars['String']>;
  elements?: Maybe<Array<IAppElement>>;
  avatarUrl: Scalars['String'];
  description: Scalars['String'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  publicationStatus: AppPublicationStatus;
  permissions: AppPermissions;
};

export enum AppElementType {
  Field = 'field',
  FormSidebar = 'formSidebar',
  Page = 'page'
}

export type IAppElement = {
  id: Scalars['ID'];
  name: Scalars['String'];
  apiId: Scalars['String'];
  type: AppElementType;
  description?: Maybe<Scalars['String']>;
  config?: Maybe<Scalars['JSON']>;
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  src: Scalars['String'];
  app: App;
};

export enum FieldAppElementFeature {
  FieldRenderer = 'FieldRenderer',
  ListRenderer = 'ListRenderer',
  TableRenderer = 'TableRenderer'
}

export type FieldAppElement = IAppElement & {
  __typename?: 'FieldAppElement';
  id: Scalars['ID'];
  name: Scalars['String'];
  apiId: Scalars['String'];
  type: AppElementType;
  description?: Maybe<Scalars['String']>;
  config?: Maybe<Scalars['JSON']>;
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  src: Scalars['String'];
  features: Array<FieldAppElementFeature>;
  fieldType: SimpleFieldType;
  app: App;
};

export type FormSidebarAppElement = IAppElement & {
  __typename?: 'FormSidebarAppElement';
  id: Scalars['ID'];
  name: Scalars['String'];
  apiId: Scalars['String'];
  type: AppElementType;
  description?: Maybe<Scalars['String']>;
  config?: Maybe<Scalars['JSON']>;
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  src: Scalars['String'];
  app: App;
};

export type PageAppElement = IAppElement & {
  __typename?: 'PageAppElement';
  id: Scalars['ID'];
  name: Scalars['String'];
  apiId: Scalars['String'];
  type: AppElementType;
  description?: Maybe<Scalars['String']>;
  config?: Maybe<Scalars['JSON']>;
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  src: Scalars['String'];
  app: App;
};

export enum AppInstallationStatus {
  Pending = 'PENDING',
  Completed = 'COMPLETED',
  Disabled = 'DISABLED'
}

export type AppInstallation = {
  __typename?: 'AppInstallation';
  id: Scalars['ID'];
  environment: Environment;
  fields: Array<IField>;
  sidebarElements: Array<AppSidebarElement>;
  app: App;
  config: Scalars['JSON'];
  status: AppInstallationStatus;
  authToken: Scalars['String'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
};

export type EnumerationValue = {
  __typename?: 'EnumerationValue';
  id: Scalars['ID'];
  apiId: Scalars['String'];
  displayName: Scalars['String'];
};

export type Enumeration = IRecentSchemaChange & {
  __typename?: 'Enumeration';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  environment: Environment;
  values: Array<EnumerationValue>;
  isSystem: Scalars['Boolean'];
  createdBy?: Maybe<CreatedBy>;
};

export type IRequireableField = {
  isRequired: Scalars['Boolean'];
};

export type IUniqueableField = {
  isUnique: Scalars['Boolean'];
};

export type ILocalizableField = {
  isLocalized: Scalars['Boolean'];
};

export type ITitleableField = {
  isTitle: Scalars['Boolean'];
};

export type FieldValidationFloatRange = {
  __typename?: 'FieldValidationFloatRange';
  min?: Maybe<Scalars['Float']>;
  max?: Maybe<Scalars['Float']>;
  errorMessage?: Maybe<Scalars['String']>;
};

export type FieldValidationRange = {
  __typename?: 'FieldValidationRange';
  min?: Maybe<Scalars['Int']>;
  max?: Maybe<Scalars['Int']>;
  errorMessage?: Maybe<Scalars['String']>;
};

export type FieldValidationRegEx = {
  __typename?: 'FieldValidationRegEx';
  regex?: Maybe<Scalars['String']>;
  flags?: Maybe<Array<Scalars['String']>>;
  errorMessage?: Maybe<Scalars['String']>;
};

export type StringFieldValidations = {
  __typename?: 'StringFieldValidations';
  characters?: Maybe<FieldValidationRange>;
  listItemCount?: Maybe<FieldValidationRange>;
  matches?: Maybe<FieldValidationRegEx>;
  notMatches?: Maybe<FieldValidationRegEx>;
};

export type IntFieldValidations = {
  __typename?: 'IntFieldValidations';
  range?: Maybe<FieldValidationRange>;
  listItemCount?: Maybe<FieldValidationRange>;
};

export type FloatFieldValidations = {
  __typename?: 'FloatFieldValidations';
  range?: Maybe<FieldValidationFloatRange>;
  listItemCount?: Maybe<FieldValidationRange>;
};

export type SimpleFieldValidations = StringFieldValidations | IntFieldValidations | FloatFieldValidations;

export type IField = {
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  isSystem: Scalars['Boolean'];
  isList: Scalars['Boolean'];
  position: Scalars['Int'];
  /** @deprecated Use visibility instead */
  isHidden: Scalars['Boolean'];
  visibility: VisibilityTypes;
  /**
   * This will throw a runtime error for fields that are on a component instead of model!
   * @deprecated Use parent instead
   */
  model: IModel;
  parent: IFieldParent;
  tableConfig: FieldConfig;
  formConfig: FieldConfig;
  extensions?: Maybe<Scalars['JSON']>;
  meta?: Maybe<Scalars['JSON']>;
  createdBy?: Maybe<CreatedBy>;
};

/** Field types */
export enum SimpleFieldType {
  Id = 'ID',
  String = 'STRING',
  Richtext = 'RICHTEXT',
  Int = 'INT',
  Float = 'FLOAT',
  Boolean = 'BOOLEAN',
  Json = 'JSON',
  Datetime = 'DATETIME',
  Date = 'DATE',
  Location = 'LOCATION',
  Color = 'COLOR'
}

export enum RemoteFieldType {
  Graphql = 'GRAPHQL',
  Rest = 'REST'
}

export enum RemoteFieldApiMethod {
  Get = 'GET',
  Post = 'POST'
}

export enum GraphQlRemoteSourceIntrospectionMethod {
  Get = 'GET',
  Post = 'POST'
}

export enum EnumerableFieldType {
  Enumeration = 'ENUMERATION'
}

export enum RelationalFieldType {
  Relation = 'RELATION',
  Asset = 'ASSET'
}

export enum ComponentFieldType {
  Component = 'COMPONENT'
}

export enum UnionFieldType {
  Union = 'UNION'
}

export enum ComponentUnionFieldType {
  ComponentUnion = 'COMPONENT_UNION'
}

export enum VisibilityTypes {
  /** Field can be read and edited */
  ReadWrite = 'READ_WRITE',
  /** Field is shown but can't be edited in the UI, only through the API */
  ReadOnly = 'READ_ONLY',
  /** Field is not shown, but can be used by other fields such as slugs or UI Extensions */
  Hidden = 'HIDDEN',
  /** Field is not shown, and can only be read or edited through the API */
  ApiOnly = 'API_ONLY'
}

export type SimpleField = IField & IRequireableField & IUniqueableField & ILocalizableField & ITitleableField & {
  __typename?: 'SimpleField';
  id: Scalars['ID'];
  type: SimpleFieldType;
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  isSystem: Scalars['Boolean'];
  isList: Scalars['Boolean'];
  isRequired: Scalars['Boolean'];
  isUnique: Scalars['Boolean'];
  position: Scalars['Int'];
  /** @deprecated Use visibility instead */
  isHidden: Scalars['Boolean'];
  visibility: VisibilityTypes;
  isLocalized: Scalars['Boolean'];
  initialValue?: Maybe<Scalars['String']>;
  /**
   * This will throw a runtime error for fields that are on a component instead of model!
   * @deprecated Use parent instead
   */
  model: IModel;
  parent: IFieldParent;
  isTitle: Scalars['Boolean'];
  tableConfig: FieldConfig;
  formConfig: FieldConfig;
  extensions?: Maybe<Scalars['JSON']>;
  validations?: Maybe<SimpleFieldValidations>;
  meta?: Maybe<Scalars['JSON']>;
  embedsEnabled?: Maybe<Scalars['Boolean']>;
  embeddableModels?: Maybe<Array<IModel>>;
  createdBy?: Maybe<CreatedBy>;
};

export type RemoteTypeDefinition = {
  __typename?: 'RemoteTypeDefinition';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  apiId: Scalars['String'];
  sdl: Scalars['String'];
  graphqlType: Remote_Graphql_Type;
  isSystem: Scalars['Boolean'];
};

export type IRemoteFieldConfig = {
  returnType: RemoteTypeDefinition;
  /** Headers that will be sent to the remote source. Those headers will override the headers defined on the remote source if setup */
  headers?: Maybe<Scalars['JSON']>;
  method: RemoteFieldApiMethod;
  cacheTTLSeconds?: Maybe<Scalars['Int']>;
  remoteSource: IRemoteSource;
  forwardClientHeaders: Scalars['Boolean'];
};

export type GraphQlRemoteFieldConfig = IRemoteFieldConfig & {
  __typename?: 'GraphQLRemoteFieldConfig';
  returnType: RemoteTypeDefinition;
  headers?: Maybe<Scalars['JSON']>;
  method: RemoteFieldApiMethod;
  cacheTTLSeconds?: Maybe<Scalars['Int']>;
  forwardClientHeaders: Scalars['Boolean'];
  /** In case of apiType GraphQL graphqlQuery contains the GraphQL query that will be sent to the remote source */
  query?: Maybe<Scalars['String']>;
  operationName?: Maybe<Scalars['String']>;
  remoteSource: GraphQlRemoteSource;
};

export type RestRemoteFieldConfig = IRemoteFieldConfig & {
  __typename?: 'RestRemoteFieldConfig';
  returnType: RemoteTypeDefinition;
  headers?: Maybe<Scalars['JSON']>;
  method: RemoteFieldApiMethod;
  cacheTTLSeconds?: Maybe<Scalars['Int']>;
  forwardClientHeaders: Scalars['Boolean'];
  path?: Maybe<Scalars['String']>;
  remoteSource: RestRemoteSource;
};

export type RemoteField = IField & {
  __typename?: 'RemoteField';
  id: Scalars['ID'];
  type: RemoteFieldType;
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  isSystem: Scalars['Boolean'];
  position: Scalars['Int'];
  /** @deprecated Use visibility instead */
  isHidden: Scalars['Boolean'];
  visibility: VisibilityTypes;
  isList: Scalars['Boolean'];
  isRequired: Scalars['Boolean'];
  /**
   * This will throw a runtime error for fields that are on a component instead of model!
   * @deprecated Use parent instead
   */
  model: IModel;
  parent: IFieldParent;
  tableConfig: FieldConfig;
  formConfig: FieldConfig;
  extensions?: Maybe<Scalars['JSON']>;
  meta?: Maybe<Scalars['JSON']>;
  remoteConfig: IRemoteFieldConfig;
  inputArgs?: Maybe<Array<FieldInputArg>>;
  createdBy?: Maybe<CreatedBy>;
};

export type EnumerableField = IField & IRequireableField & IUniqueableField & ILocalizableField & ITitleableField & {
  __typename?: 'EnumerableField';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  type: EnumerableFieldType;
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  isSystem: Scalars['Boolean'];
  isList: Scalars['Boolean'];
  isRequired: Scalars['Boolean'];
  isUnique: Scalars['Boolean'];
  position: Scalars['Int'];
  /** @deprecated Use visibility instead */
  isHidden: Scalars['Boolean'];
  visibility: VisibilityTypes;
  isLocalized: Scalars['Boolean'];
  initialValue?: Maybe<EnumerationValue>;
  /**
   * This will throw a runtime error for fields that are on a component instead of model!
   * @deprecated Use parent instead
   */
  model: IModel;
  parent: IFieldParent;
  isTitle: Scalars['Boolean'];
  tableConfig: FieldConfig;
  formConfig: FieldConfig;
  enumeration: Enumeration;
  extensions?: Maybe<Scalars['JSON']>;
  meta?: Maybe<Scalars['JSON']>;
  createdBy?: Maybe<CreatedBy>;
};

export type RelationalField = IField & IRequireableField & {
  __typename?: 'RelationalField';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  type: RelationalFieldType;
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  isSystem: Scalars['Boolean'];
  isList: Scalars['Boolean'];
  isRequired: Scalars['Boolean'];
  position: Scalars['Int'];
  /** @deprecated Use visibility instead */
  isHidden: Scalars['Boolean'];
  visibility: VisibilityTypes;
  /**
   * This will throw a runtime error for fields that are on a component instead of model!
   * @deprecated Use parent instead
   */
  model: IModel;
  parent: IFieldParent;
  tableConfig: FieldConfig;
  formConfig: FieldConfig;
  relatedModel: IModel;
  relatedField: RelationalField;
  extensions?: Maybe<Scalars['JSON']>;
  meta?: Maybe<Scalars['JSON']>;
  createdBy?: Maybe<CreatedBy>;
};

export type UniDirectionalRelationalField = IField & IRequireableField & {
  __typename?: 'UniDirectionalRelationalField';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  type: RelationalFieldType;
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  isSystem: Scalars['Boolean'];
  isList: Scalars['Boolean'];
  isRequired: Scalars['Boolean'];
  position: Scalars['Int'];
  /** @deprecated Use visibility instead */
  isHidden: Scalars['Boolean'];
  visibility: VisibilityTypes;
  /**
   * This will throw a runtime error for fields that are on a component instead of model!
   * @deprecated Use parent instead
   */
  model: IModel;
  parent: IFieldParent;
  tableConfig: FieldConfig;
  formConfig: FieldConfig;
  relatedModel: IModel;
  extensions?: Maybe<Scalars['JSON']>;
  meta?: Maybe<Scalars['JSON']>;
  createdBy?: Maybe<CreatedBy>;
};

export type ComponentField = IField & IRequireableField & {
  __typename?: 'ComponentField';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  type: ComponentFieldType;
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  isSystem: Scalars['Boolean'];
  isList: Scalars['Boolean'];
  isRequired: Scalars['Boolean'];
  position: Scalars['Int'];
  /** @deprecated Use visibility instead */
  isHidden: Scalars['Boolean'];
  visibility: VisibilityTypes;
  /**
   * This will throw a runtime error for fields that are on a component instead of model!
   * @deprecated Use parent instead
   */
  model: IModel;
  parent: IFieldParent;
  hasEmptyValues: Scalars['Boolean'];
  tableConfig: FieldConfig;
  formConfig: FieldConfig;
  component: Component;
  extensions?: Maybe<Scalars['JSON']>;
  meta?: Maybe<Scalars['JSON']>;
  createdBy?: Maybe<CreatedBy>;
};

export type UnionField = IField & IUnionField & {
  __typename?: 'UnionField';
  id: Scalars['ID'];
  type: UnionFieldType;
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  isSystem: Scalars['Boolean'];
  isList: Scalars['Boolean'];
  position: Scalars['Int'];
  /** @deprecated Use visibility instead */
  isHidden: Scalars['Boolean'];
  visibility: VisibilityTypes;
  /**
   * This will throw a runtime error for fields that are on a component instead of model!
   * @deprecated Use parent instead
   */
  model: IModel;
  parent: IFieldParent;
  tableConfig: FieldConfig;
  formConfig: FieldConfig;
  /** True if this field is the reverse side of the initally created union field */
  isMemberType: Scalars['Boolean'];
  union: Union;
  extensions?: Maybe<Scalars['JSON']>;
  meta?: Maybe<Scalars['JSON']>;
  createdBy?: Maybe<CreatedBy>;
};

export type ComponentUnionField = IField & IRequireableField & {
  __typename?: 'ComponentUnionField';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  type: ComponentUnionFieldType;
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  isSystem: Scalars['Boolean'];
  isList: Scalars['Boolean'];
  isRequired: Scalars['Boolean'];
  position: Scalars['Int'];
  /** @deprecated Use visibility instead */
  isHidden: Scalars['Boolean'];
  visibility: VisibilityTypes;
  /**
   * This will throw a runtime error for fields that are on a component instead of model!
   * @deprecated Use parent instead
   */
  model: IModel;
  parent: IFieldParent;
  tableConfig: FieldConfig;
  formConfig: FieldConfig;
  components: Array<Component>;
  extensions?: Maybe<Scalars['JSON']>;
  meta?: Maybe<Scalars['JSON']>;
  createdBy?: Maybe<CreatedBy>;
};

export type Union = {
  __typename?: 'Union';
  id: Scalars['ID'];
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  memberTypes: Array<UnionField>;
  field: UnionField;
};

export type IUnionField = {
  /** True if this field is the reverse side of the initally created union field */
  isMemberType: Scalars['Boolean'];
  union: Union;
};

export type FieldConfig = {
  __typename?: 'FieldConfig';
  config: Scalars['JSON'];
  id: Scalars['String'];
  renderer: Scalars['String'];
  extension?: Maybe<FieldExtension>;
  appInstallation?: Maybe<AppInstallation>;
  appElement?: Maybe<FieldAppElement>;
};

export type FieldValidationIntRangeInput = {
  min?: InputMaybe<Scalars['Int']>;
  max?: InputMaybe<Scalars['Int']>;
  errorMessage?: InputMaybe<Scalars['String']>;
};

export type FieldValidationFloatRangeInput = {
  min?: InputMaybe<Scalars['Float']>;
  max?: InputMaybe<Scalars['Float']>;
  errorMessage?: InputMaybe<Scalars['String']>;
};

export type FieldValidationRegExInput = {
  regex?: InputMaybe<Scalars['String']>;
  flags?: InputMaybe<Array<Scalars['String']>>;
  errorMessage?: InputMaybe<Scalars['String']>;
};

export type IntFieldValidationsInput = {
  range?: InputMaybe<FieldValidationIntRangeInput>;
  listItemCount?: InputMaybe<FieldValidationIntRangeInput>;
};

export type FloatFieldValidationsInput = {
  range?: InputMaybe<FieldValidationFloatRangeInput>;
  listItemCount?: InputMaybe<FieldValidationIntRangeInput>;
};

export type StringFieldValidationsInput = {
  characters?: InputMaybe<FieldValidationIntRangeInput>;
  listItemCount?: InputMaybe<FieldValidationIntRangeInput>;
  matches?: InputMaybe<FieldValidationRegExInput>;
  notMatches?: InputMaybe<FieldValidationRegExInput>;
};

export type SimpleFieldValidationsInput = {
  Int?: InputMaybe<IntFieldValidationsInput>;
  Float?: InputMaybe<FloatFieldValidationsInput>;
  String?: InputMaybe<StringFieldValidationsInput>;
};

export type FieldConfigInput = {
  renderer: Scalars['String'];
  config: Scalars['JSON'];
  extensionId?: InputMaybe<Scalars['ID']>;
  appInstallationId?: InputMaybe<Scalars['ID']>;
  appElementId?: InputMaybe<Scalars['ID']>;
};

export type FieldInputArg = {
  __typename?: 'FieldInputArg';
  id: Scalars['ID'];
  apiId: Scalars['String'];
  isRequired: Scalars['Boolean'];
  isList: Scalars['Boolean'];
  remoteType: RemoteTypeDefinition;
};

export type BatchMigrationRemoteFieldInputArgInput = {
  remoteTypeApiId: Scalars['String'];
  apiId: Scalars['String'];
  isRequired: Scalars['Boolean'];
  isList: Scalars['Boolean'];
};

export type BatchMigrationRemoteFieldConfigInput = {
  returnTypeApiId: Scalars['String'];
  headers?: InputMaybe<Scalars['JSON']>;
  method: RemoteFieldApiMethod;
  cacheTTLSeconds?: InputMaybe<Scalars['Int']>;
  remoteSourcePrefix: Scalars['String'];
  /** In case of apiType GraphQL graphqlQuery contains the GraphQL query that will be sent to the remote source */
  graphQLQuery?: InputMaybe<Scalars['String']>;
  /** In case of apiType REST restPath contains the path that will be appended to the API base url */
  restPath?: InputMaybe<Scalars['String']>;
  /** If true, headers that are sent by the client will be forwarded to the remote source */
  forwardClientHeaders?: InputMaybe<Scalars['Boolean']>;
};

export type BatchMigrationUpdateRemoteFieldConfigInput = {
  returnTypeApiId?: InputMaybe<Scalars['String']>;
  remoteSourcePrefix?: InputMaybe<Scalars['String']>;
  headers?: InputMaybe<Scalars['JSON']>;
  method?: InputMaybe<RemoteFieldApiMethod>;
  cacheTTLSeconds?: InputMaybe<Scalars['Int']>;
  /** In case of apiType GraphQL graphqlQuery contains the GraphQL query that will be sent to the remote source */
  graphQLQuery?: InputMaybe<Scalars['String']>;
  /** In case of apiType REST restPath contains the path that will be appended to the API base url */
  restPath?: InputMaybe<Scalars['String']>;
  /** If true, headers that are sent by the client will be forwarded to the remote source */
  forwardClientHeaders?: InputMaybe<Scalars['Boolean']>;
};

export type BatchMigrationUpsertFieldInputArgInputToCreateInput = {
  remoteTypeApiId: Scalars['String'];
  apiId: Scalars['String'];
  isRequired: Scalars['Boolean'];
  isList: Scalars['Boolean'];
};

export type BatchMigrationUpsertFieldInputArgInputToUpdateInput = {
  argApiId: Scalars['String'];
  remoteTypeApiId?: InputMaybe<Scalars['String']>;
  apiId?: InputMaybe<Scalars['String']>;
  isRequired?: InputMaybe<Scalars['Boolean']>;
  isList?: InputMaybe<Scalars['Boolean']>;
};

export type BatchMigrationUpsertFieldInputArgInputToDeleteInput = {
  argApiId: Scalars['String'];
};

export type BatchMigrationUpsertFieldInputArgInput = {
  fieldInputArgsToCreate?: InputMaybe<Array<BatchMigrationUpsertFieldInputArgInputToCreateInput>>;
  fieldInputArgsToDelete?: InputMaybe<Array<BatchMigrationUpsertFieldInputArgInputToDeleteInput>>;
  fieldInputArgsToUpdate?: InputMaybe<Array<BatchMigrationUpsertFieldInputArgInputToUpdateInput>>;
};

/**
 * This types holds a superset of the allowed read operations on a model.
 * This means even if this states access is allowed, it could still potentially be denied.
 */
export type ModelViewerReadContentPermission = {
  __typename?: 'ModelViewerReadContentPermission';
  allowedWithCondition: Scalars['Boolean'];
  allowedLocales: Array<Locale>;
};

export type ModelViewerReadContentPermissionByStage = {
  __typename?: 'ModelViewerReadContentPermissionByStage';
  stage: Stage;
  /**
   * If the current viewer is allowed to read this models content for the provided stage,
   * this field will return the potential limitations that must be met.
   * `null` means not allowed!
   */
  allowed?: Maybe<ModelViewerReadContentPermission>;
};

export type ModelViewerContentPermission = {
  __typename?: 'ModelViewerContentPermission';
  /** Lists all stages and the corresponding read permissions the user has on those stages. */
  readByStages: Array<ModelViewerReadContentPermissionByStage>;
  readVersion: Scalars['Boolean'];
};

/** Simplified computed version of the permissions the current viewer has on this model */
export type ModelViewerPermission = {
  __typename?: 'ModelViewerPermission';
  content: ModelViewerContentPermission;
};

export type IFieldParent = {
  id: Scalars['ID'];
  apiId: Scalars['String'];
  displayName: Scalars['String'];
};

export type CreatedBy = PermanentAuthToken | Member | AppToken;

export type FieldsAggregate = {
  __typename?: 'FieldsAggregate';
  count: Scalars['Int'];
};

export type FieldsConnection = {
  __typename?: 'FieldsConnection';
  pageInfo: PageInfo;
  edges: Array<FieldEdge>;
  aggregate: FieldsAggregate;
};

export type FieldEdge = {
  __typename?: 'FieldEdge';
  node: IField;
};

export type IModel = {
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  createdBy?: Maybe<CreatedBy>;
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  isSystem: Scalars['Boolean'];
  apiIdPlural: Scalars['String'];
  isLocalized: Scalars['Boolean'];
  titleFields: Array<IField>;
  fields: Array<IField>;
  fieldsConnection: FieldsConnection;
  field: IField;
  environment: Environment;
  contentViews: Array<ContentView>;
  /** Model has at least one document */
  hasContent: Scalars['Boolean'];
  isVersioned: Scalars['Boolean'];
  viewerPermission: ModelViewerPermission;
  sidebarElements: Array<ISidebarElement>;
  hasLocalizedComponents: Scalars['Boolean'];
};


export type IModelFieldsArgs = {
  includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
  includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
};


export type IModelFieldsConnectionArgs = {
  skip?: Scalars['Int'];
  first?: Scalars['Int'];
  includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
  includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
  includeSystemFields?: InputMaybe<Scalars['Boolean']>;
};


export type IModelFieldArgs = {
  id: Scalars['ID'];
};


export type IModelContentViewsArgs = {
  includeSystemContentViews?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<ContentViewFilterInput>;
};

export type ISidebarElement = {
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  config?: Maybe<Scalars['JSON']>;
  position: Scalars['Int'];
  isEnabled: Scalars['Boolean'];
  model: IModel;
};

export type CustomSidebarElement = ISidebarElement & {
  __typename?: 'CustomSidebarElement';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  config?: Maybe<Scalars['JSON']>;
  position: Scalars['Int'];
  isEnabled: Scalars['Boolean'];
  model: IModel;
  extension: SidebarExtension;
};

export enum SystemSidebarElementType {
  Information = 'INFORMATION',
  Stages = 'STAGES',
  Localizations = 'LOCALIZATIONS',
  Versions = 'VERSIONS',
  PreviewUrls = 'PREVIEW_URLS',
  Releases = 'RELEASES'
}

export type SystemSidebarElement = ISidebarElement & {
  __typename?: 'SystemSidebarElement';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  config?: Maybe<Scalars['JSON']>;
  position: Scalars['Int'];
  isEnabled: Scalars['Boolean'];
  model: IModel;
  type: SystemSidebarElementType;
};

export type ExtensionSidebarElement = ISidebarElement & {
  __typename?: 'ExtensionSidebarElement';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  config?: Maybe<Scalars['JSON']>;
  position: Scalars['Int'];
  isEnabled: Scalars['Boolean'];
  model: IModel;
  extension: SidebarExtension;
};

export type AppSidebarElement = ISidebarElement & {
  __typename?: 'AppSidebarElement';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  config?: Maybe<Scalars['JSON']>;
  position: Scalars['Int'];
  isEnabled: Scalars['Boolean'];
  model: IModel;
  appElement: FormSidebarAppElement;
  appInstallation: AppInstallation;
};

export type Model = IModel & IFieldParent & IRecentSchemaChange & {
  __typename?: 'Model';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  createdBy?: Maybe<CreatedBy>;
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  isSystem: Scalars['Boolean'];
  apiIdPlural: Scalars['String'];
  /** Is true when at least one field is marked as localized */
  isLocalized: Scalars['Boolean'];
  titleFields: Array<IField>;
  fields: Array<IField>;
  fieldsConnection: FieldsConnection;
  field: IField;
  environment: Environment;
  contentViews: Array<ContentView>;
  defaultContentView: ContentView;
  /** Model has at least one document */
  hasContent: Scalars['Boolean'];
  isVersioned: Scalars['Boolean'];
  viewerPermission: ModelViewerPermission;
  sidebarElements: Array<ISidebarElement>;
  hasLocalizedComponents: Scalars['Boolean'];
};


export type ModelFieldsArgs = {
  includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
  includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
};


export type ModelFieldsConnectionArgs = {
  skip?: Scalars['Int'];
  first?: Scalars['Int'];
  includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
  includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
  includeSystemFields?: InputMaybe<Scalars['Boolean']>;
};


export type ModelFieldArgs = {
  id: Scalars['ID'];
};


export type ModelContentViewsArgs = {
  includeSystemContentViews?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<ContentViewFilterInput>;
};

export type Component = IFieldParent & IRecentSchemaChange & {
  __typename?: 'Component';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  createdBy?: Maybe<CreatedBy>;
  apiId: Scalars['String'];
  apiIdPlural: Scalars['String'];
  isSystem: Scalars['Boolean'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  /** Is true when at least one field is marked as localized */
  isLocalized: Scalars['Boolean'];
  titleFields: Array<IField>;
  fields: Array<IField>;
  fieldsConnection: FieldsConnection;
  field: IField;
  environment: Environment;
  /** Component has at least one instance in any of its usages */
  hasContent: Scalars['Boolean'];
};


export type ComponentFieldsArgs = {
  includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
  includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
};


export type ComponentFieldsConnectionArgs = {
  skip?: Scalars['Int'];
  first?: Scalars['Int'];
  includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
  includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
  includeSystemFields?: InputMaybe<Scalars['Boolean']>;
};


export type ComponentFieldArgs = {
  id: Scalars['ID'];
};

export type AssetModel = IModel & IFieldParent & {
  __typename?: 'AssetModel';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  createdBy?: Maybe<CreatedBy>;
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  isSystem: Scalars['Boolean'];
  apiIdPlural: Scalars['String'];
  isLocalized: Scalars['Boolean'];
  titleFields: Array<IField>;
  fields: Array<IField>;
  fieldsConnection: FieldsConnection;
  field: IField;
  environment: Environment;
  contentViews: Array<ContentView>;
  defaultContentView: ContentView;
  /** Model has at least one document */
  hasContent: Scalars['Boolean'];
  isVersioned: Scalars['Boolean'];
  viewerPermission: ModelViewerPermission;
  sidebarElements: Array<ISidebarElement>;
  hasLocalizedComponents: Scalars['Boolean'];
};


export type AssetModelFieldsArgs = {
  includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
  includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
};


export type AssetModelFieldsConnectionArgs = {
  skip?: Scalars['Int'];
  first?: Scalars['Int'];
  includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
  includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
  includeSystemFields?: InputMaybe<Scalars['Boolean']>;
};


export type AssetModelFieldArgs = {
  id: Scalars['ID'];
};


export type AssetModelContentViewsArgs = {
  includeSystemContentViews?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<ContentViewFilterInput>;
};

export type UserModel = IModel & IFieldParent & {
  __typename?: 'UserModel';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  createdBy?: Maybe<CreatedBy>;
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  isSystem: Scalars['Boolean'];
  apiIdPlural: Scalars['String'];
  isLocalized: Scalars['Boolean'];
  titleFields: Array<IField>;
  fields: Array<IField>;
  fieldsConnection: FieldsConnection;
  field: IField;
  environment: Environment;
  contentViews: Array<ContentView>;
  /** Model has at least one document */
  hasContent: Scalars['Boolean'];
  isVersioned: Scalars['Boolean'];
  viewerPermission: ModelViewerPermission;
  sidebarElements: Array<ISidebarElement>;
  hasLocalizedComponents: Scalars['Boolean'];
};


export type UserModelFieldsArgs = {
  includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
  includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
};


export type UserModelFieldsConnectionArgs = {
  skip?: Scalars['Int'];
  first?: Scalars['Int'];
  includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
  includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
  includeSystemFields?: InputMaybe<Scalars['Boolean']>;
};


export type UserModelFieldArgs = {
  id: Scalars['ID'];
};


export type UserModelContentViewsArgs = {
  includeSystemContentViews?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<ContentViewFilterInput>;
};

export type SchedulingModel = IModel & IFieldParent & {
  __typename?: 'SchedulingModel';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  createdBy?: Maybe<CreatedBy>;
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  isSystem: Scalars['Boolean'];
  apiIdPlural: Scalars['String'];
  isLocalized: Scalars['Boolean'];
  titleFields: Array<IField>;
  fields: Array<IField>;
  fieldsConnection: FieldsConnection;
  field: IField;
  environment: Environment;
  contentViews: Array<ContentView>;
  /** Model has at least one document */
  hasContent: Scalars['Boolean'];
  isVersioned: Scalars['Boolean'];
  viewerPermission: ModelViewerPermission;
  sidebarElements: Array<ISidebarElement>;
  hasLocalizedComponents: Scalars['Boolean'];
};


export type SchedulingModelFieldsArgs = {
  includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
  includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
};


export type SchedulingModelFieldsConnectionArgs = {
  skip?: Scalars['Int'];
  first?: Scalars['Int'];
  includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
  includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
  includeSystemFields?: InputMaybe<Scalars['Boolean']>;
};


export type SchedulingModelFieldArgs = {
  id: Scalars['ID'];
};


export type SchedulingModelContentViewsArgs = {
  includeSystemContentViews?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<ContentViewFilterInput>;
};

export type QueryModel = IModel & IFieldParent & {
  __typename?: 'QueryModel';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  createdBy?: Maybe<CreatedBy>;
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  isSystem: Scalars['Boolean'];
  apiIdPlural: Scalars['String'];
  isLocalized: Scalars['Boolean'];
  titleFields: Array<IField>;
  fields: Array<IField>;
  fieldsConnection: FieldsConnection;
  field: IField;
  environment: Environment;
  contentViews: Array<ContentView>;
  /** Model has at least one document */
  hasContent: Scalars['Boolean'];
  isVersioned: Scalars['Boolean'];
  viewerPermission: ModelViewerPermission;
  sidebarElements: Array<ISidebarElement>;
  hasLocalizedComponents: Scalars['Boolean'];
};


export type QueryModelFieldsArgs = {
  includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
  includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
};


export type QueryModelFieldsConnectionArgs = {
  skip?: Scalars['Int'];
  first?: Scalars['Int'];
  includeHiddenFields?: InputMaybe<Scalars['Boolean']>;
  includeApiOnlyFields?: InputMaybe<Scalars['Boolean']>;
  includeSystemFields?: InputMaybe<Scalars['Boolean']>;
};


export type QueryModelFieldArgs = {
  id: Scalars['ID'];
};


export type QueryModelContentViewsArgs = {
  includeSystemContentViews?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<ContentViewFilterInput>;
};

export type Locale = {
  __typename?: 'Locale';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  /**
   * Specifies if the locale is used as the
   * default locale which impacts the Content API
   */
  isDefault: Scalars['Boolean'];
  /**
   * Determines how the locale is
   * exposed in the Content API
   */
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
};

export type AsyncOperationPayload = {
  __typename?: 'AsyncOperationPayload';
  migration: Migration;
};

/** Creating a model. */
export type BatchMigrationCreateModelInput = {
  /** The model apiId */
  apiId: Scalars['String'];
  /** The models plural apiId. This is used for lists */
  apiIdPlural: Scalars['String'];
  /** Display name that is used to render the model in the webapp */
  displayName: Scalars['String'];
  /** Optional description of the model */
  description?: InputMaybe<Scalars['String']>;
  /** Only AppTokens should provide this flag */
  isSystem?: InputMaybe<Scalars['Boolean']>;
};

/** Updating a model. */
export type BatchMigrationUpdateModelInput = {
  apiId: Scalars['String'];
  newApiId?: InputMaybe<Scalars['String']>;
  apiIdPlural?: InputMaybe<Scalars['String']>;
  displayName?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  isSystem?: InputMaybe<Scalars['Boolean']>;
};

/** Deleting a model. */
export type BatchMigrationDeleteModelInput = {
  apiId: Scalars['String'];
};

/** Creating a component. */
export type BatchMigrationCreateComponentInput = {
  apiId: Scalars['String'];
  apiIdPlural: Scalars['String'];
  displayName: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
};

/** Updating a component. */
export type BatchMigrationUpdateComponentInput = {
  apiId: Scalars['String'];
  newApiId?: InputMaybe<Scalars['String']>;
  apiIdPlural?: InputMaybe<Scalars['String']>;
  displayName?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
};

/** Deleting a component. */
export type BatchMigrationDeleteComponentInput = {
  apiId: Scalars['String'];
};

/** Deleting a stage. */
export type BatchMigrationDeleteStageInput = {
  apiId: Scalars['String'];
};

/** Updating a stage */
export type BatchMigrationUpdateStageInput = {
  apiId: Scalars['String'];
  newApiId?: InputMaybe<Scalars['String']>;
  color?: InputMaybe<ColorPalette>;
  display?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  position?: InputMaybe<Scalars['Int']>;
};

/** Creating a stage. */
export type BatchMigrationCreateStageInput = {
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  color: ColorPalette;
  description?: InputMaybe<Scalars['String']>;
  position?: InputMaybe<Scalars['Int']>;
};

/** Deleting a field. */
export type BatchMigrationDeleteFieldInput = {
  apiId: Scalars['String'];
  modelApiId?: InputMaybe<Scalars['String']>;
  parentApiId?: InputMaybe<Scalars['String']>;
};

/** Creating a simple field. */
export type BatchMigrationEmbeddableModelsInput = {
  modelsToAdd?: InputMaybe<Array<Scalars['String']>>;
  modelsToRemove?: InputMaybe<Array<Scalars['String']>>;
};

/** Creating a simple field. */
export type BatchMigrationCreateSimpleFieldInput = {
  apiId: Scalars['String'];
  modelApiId?: InputMaybe<Scalars['String']>;
  parentApiId?: InputMaybe<Scalars['String']>;
  type: SimpleFieldType;
  displayName: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  initialValue?: InputMaybe<Scalars['String']>;
  tableRenderer?: InputMaybe<Scalars['String']>;
  formRenderer?: InputMaybe<Scalars['String']>;
  tableExtension?: InputMaybe<Scalars['String']>;
  formExtension?: InputMaybe<Scalars['String']>;
  formConfig?: InputMaybe<Scalars['JSON']>;
  tableConfig?: InputMaybe<Scalars['JSON']>;
  isList?: InputMaybe<Scalars['Boolean']>;
  isLocalized?: InputMaybe<Scalars['Boolean']>;
  isRequired?: InputMaybe<Scalars['Boolean']>;
  isUnique?: InputMaybe<Scalars['Boolean']>;
  isHidden?: InputMaybe<Scalars['Boolean']>;
  visibility?: InputMaybe<VisibilityTypes>;
  isTitle?: InputMaybe<Scalars['Boolean']>;
  position?: InputMaybe<Scalars['Int']>;
  validations?: InputMaybe<SimpleFieldValidationsInput>;
  migrationValue?: InputMaybe<Scalars['String']>;
  embedsEnabled?: InputMaybe<Scalars['Boolean']>;
  embeddableModels?: InputMaybe<Array<Scalars['String']>>;
  isSystem?: InputMaybe<Scalars['Boolean']>;
};

export type BatchMigrationCreateRemoteFieldInput = {
  apiId: Scalars['String'];
  parentApiId: Scalars['String'];
  type: RemoteFieldType;
  displayName: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  tableRenderer?: InputMaybe<Scalars['String']>;
  formRenderer?: InputMaybe<Scalars['String']>;
  tableExtension?: InputMaybe<Scalars['String']>;
  formExtension?: InputMaybe<Scalars['String']>;
  formConfig?: InputMaybe<Scalars['JSON']>;
  tableConfig?: InputMaybe<Scalars['JSON']>;
  isList?: InputMaybe<Scalars['Boolean']>;
  isRequired?: InputMaybe<Scalars['Boolean']>;
  visibility?: InputMaybe<VisibilityTypes>;
  position?: InputMaybe<Scalars['Int']>;
  remoteConfig: BatchMigrationRemoteFieldConfigInput;
  inputArgs?: InputMaybe<Array<BatchMigrationRemoteFieldInputArgInput>>;
};

export type BatchMigrationUpdateRemoteFieldInput = {
  apiId: Scalars['String'];
  newApiId?: InputMaybe<Scalars['String']>;
  parentApiId: Scalars['String'];
  remoteConfig?: InputMaybe<BatchMigrationUpdateRemoteFieldConfigInput>;
  inputArgs?: InputMaybe<BatchMigrationUpsertFieldInputArgInput>;
  isList?: InputMaybe<Scalars['Boolean']>;
  isRequired?: InputMaybe<Scalars['Boolean']>;
  displayName?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  visibility?: InputMaybe<VisibilityTypes>;
  formConfig?: InputMaybe<FieldConfigInput>;
  tableConfig?: InputMaybe<FieldConfigInput>;
  extensions?: InputMaybe<Scalars['JSON']>;
  meta?: InputMaybe<Scalars['JSON']>;
};

/** Creating an enumerable field. */
export type BatchMigrationCreateEnumerableFieldInput = {
  apiId: Scalars['String'];
  modelApiId?: InputMaybe<Scalars['String']>;
  parentApiId?: InputMaybe<Scalars['String']>;
  enumerationApiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  tableRenderer?: InputMaybe<Scalars['String']>;
  formRenderer?: InputMaybe<Scalars['String']>;
  tableExtension?: InputMaybe<Scalars['String']>;
  formExtension?: InputMaybe<Scalars['String']>;
  isList?: InputMaybe<Scalars['Boolean']>;
  isLocalized?: InputMaybe<Scalars['Boolean']>;
  isRequired?: InputMaybe<Scalars['Boolean']>;
  isUnique?: InputMaybe<Scalars['Boolean']>;
  isHidden?: InputMaybe<Scalars['Boolean']>;
  migrationValue?: InputMaybe<Scalars['String']>;
  visibility?: InputMaybe<VisibilityTypes>;
  isTitle?: InputMaybe<Scalars['Boolean']>;
  position?: InputMaybe<Scalars['Int']>;
  isSystem?: InputMaybe<Scalars['Boolean']>;
};

/** updating a union field */
export type BatchMigrationUpdateUnionFieldInput = {
  apiId: Scalars['String'];
  newApiId?: InputMaybe<Scalars['String']>;
  modelApiId?: InputMaybe<Scalars['String']>;
  parentApiId?: InputMaybe<Scalars['String']>;
  displayName?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  visibility?: InputMaybe<VisibilityTypes>;
  reverseField?: InputMaybe<BatchMigrationUpdateReverseUnionFieldInput>;
};

/** Creating a union field */
export type BatchMigrationCreateUnionFieldInput = {
  apiId: Scalars['String'];
  modelApiId?: InputMaybe<Scalars['String']>;
  parentApiId?: InputMaybe<Scalars['String']>;
  displayName: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  tableRenderer?: InputMaybe<Scalars['String']>;
  formRenderer?: InputMaybe<Scalars['String']>;
  tableExtension?: InputMaybe<Scalars['String']>;
  formExtension?: InputMaybe<Scalars['String']>;
  isList?: InputMaybe<Scalars['Boolean']>;
  isHidden?: InputMaybe<Scalars['Boolean']>;
  visibility?: InputMaybe<VisibilityTypes>;
  reverseField: BatchMigrationCreateReverseUnionFieldInput;
};

/** updating a component-union field */
export type BatchMigrationUpdateComponentUnionFieldInput = {
  apiId: Scalars['String'];
  newApiId?: InputMaybe<Scalars['String']>;
  parentApiId: Scalars['String'];
  displayName?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  componentApiIds?: InputMaybe<Array<Scalars['String']>>;
};

/** Creating a component-union field */
export type BatchMigrationCreateComponentUnionFieldInput = {
  apiId: Scalars['String'];
  parentApiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  tableRenderer?: InputMaybe<Scalars['String']>;
  formRenderer?: InputMaybe<Scalars['String']>;
  tableExtension?: InputMaybe<Scalars['String']>;
  formExtension?: InputMaybe<Scalars['String']>;
  isList?: InputMaybe<Scalars['Boolean']>;
  isRequired?: InputMaybe<Scalars['Boolean']>;
  visibility?: InputMaybe<VisibilityTypes>;
  componentApiIds: Array<Scalars['String']>;
};

/** reverse field args */
export type BatchMigrationCreateReverseUnionFieldInput = {
  apiId?: InputMaybe<Scalars['String']>;
  modelApiIds: Array<Scalars['String']>;
  displayName?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  isList?: InputMaybe<Scalars['Boolean']>;
  isHidden?: InputMaybe<Scalars['Boolean']>;
  visibility?: InputMaybe<VisibilityTypes>;
};

/** reverse field args */
export type BatchMigrationUpdateReverseUnionFieldInput = {
  modelApiIds: Array<Scalars['String']>;
};

/** Creating a relational field */
export type BatchMigrationCreateRelationalFieldInput = {
  apiId: Scalars['String'];
  modelApiId?: InputMaybe<Scalars['String']>;
  parentApiId?: InputMaybe<Scalars['String']>;
  type: RelationalFieldType;
  displayName: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  tableRenderer?: InputMaybe<Scalars['String']>;
  formRenderer?: InputMaybe<Scalars['String']>;
  tableExtension?: InputMaybe<Scalars['String']>;
  formExtension?: InputMaybe<Scalars['String']>;
  isList?: InputMaybe<Scalars['Boolean']>;
  /**
   * Marks the field as required.
   * Note: This is only supported for RelationFieldType ASSET!
   */
  isRequired?: InputMaybe<Scalars['Boolean']>;
  isHidden?: InputMaybe<Scalars['Boolean']>;
  visibility?: InputMaybe<VisibilityTypes>;
  reverseField: BatchMigrationCreateReverseRelationalFieldInput;
};

/** Creating a component field */
export type BatchMigrationCreateComponentFieldInput = {
  apiId: Scalars['String'];
  parentApiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  tableRenderer?: InputMaybe<Scalars['String']>;
  formRenderer?: InputMaybe<Scalars['String']>;
  tableExtension?: InputMaybe<Scalars['String']>;
  formExtension?: InputMaybe<Scalars['String']>;
  isList?: InputMaybe<Scalars['Boolean']>;
  isRequired?: InputMaybe<Scalars['Boolean']>;
  visibility?: InputMaybe<VisibilityTypes>;
  componentApiId: Scalars['String'];
  position?: InputMaybe<Scalars['Int']>;
};

/** reverse field args */
export type BatchMigrationCreateReverseRelationalFieldInput = {
  apiId: Scalars['String'];
  modelApiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  isList?: InputMaybe<Scalars['Boolean']>;
  isHidden?: InputMaybe<Scalars['Boolean']>;
  visibility?: InputMaybe<VisibilityTypes>;
  isUnidirectional?: InputMaybe<Scalars['Boolean']>;
};

/** Updating relational field */
export type BatchMigrationUpdateRelationalFieldInput = {
  apiId: Scalars['String'];
  newApiId?: InputMaybe<Scalars['String']>;
  modelApiId?: InputMaybe<Scalars['String']>;
  parentApiId?: InputMaybe<Scalars['String']>;
  displayName?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  isList?: InputMaybe<Scalars['Boolean']>;
  isHidden?: InputMaybe<Scalars['Boolean']>;
  visibility?: InputMaybe<VisibilityTypes>;
  isUnidirectional?: InputMaybe<Scalars['Boolean']>;
  /**
   * Marks the field as required.
   * Note: This is only supported for RelationFieldType ASSET!
   */
  isRequired?: InputMaybe<Scalars['Boolean']>;
};

/** Updating component field */
export type BatchMigrationUpdateComponentFieldInput = {
  apiId: Scalars['String'];
  newApiId?: InputMaybe<Scalars['String']>;
  parentApiId: Scalars['String'];
  displayName?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  isList?: InputMaybe<Scalars['Boolean']>;
  visibility?: InputMaybe<VisibilityTypes>;
  isRequired?: InputMaybe<Scalars['Boolean']>;
};

/** Updating simple field */
export type BatchMigrationUpdateSimpleFieldInput = {
  apiId: Scalars['String'];
  newApiId?: InputMaybe<Scalars['String']>;
  modelApiId?: InputMaybe<Scalars['String']>;
  parentApiId?: InputMaybe<Scalars['String']>;
  displayName?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  isList?: InputMaybe<Scalars['Boolean']>;
  isLocalized?: InputMaybe<Scalars['Boolean']>;
  isRequired?: InputMaybe<Scalars['Boolean']>;
  isUnique?: InputMaybe<Scalars['Boolean']>;
  isHidden?: InputMaybe<Scalars['Boolean']>;
  visibility?: InputMaybe<VisibilityTypes>;
  isTitle?: InputMaybe<Scalars['Boolean']>;
  position?: InputMaybe<Scalars['Int']>;
  initialValue?: InputMaybe<Scalars['String']>;
  migrationValue?: InputMaybe<Scalars['String']>;
  validations?: InputMaybe<SimpleFieldValidationsInput>;
  embedsEnabled?: InputMaybe<Scalars['Boolean']>;
  tableRenderer?: InputMaybe<Scalars['String']>;
  formRenderer?: InputMaybe<Scalars['String']>;
  tableExtension?: InputMaybe<Scalars['String']>;
  formExtension?: InputMaybe<Scalars['String']>;
  formConfig?: InputMaybe<Scalars['JSON']>;
  tableConfig?: InputMaybe<Scalars['JSON']>;
  embeddableModels?: InputMaybe<BatchMigrationEmbeddableModelsInput>;
  isSystem?: InputMaybe<Scalars['Boolean']>;
};

/** Updating enumerable field */
export type BatchMigrationUpdateEnumerableFieldInput = {
  apiId: Scalars['String'];
  newApiId?: InputMaybe<Scalars['String']>;
  modelApiId?: InputMaybe<Scalars['String']>;
  parentApiId?: InputMaybe<Scalars['String']>;
  displayName?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  isList?: InputMaybe<Scalars['Boolean']>;
  isLocalized?: InputMaybe<Scalars['Boolean']>;
  isRequired?: InputMaybe<Scalars['Boolean']>;
  isUnique?: InputMaybe<Scalars['Boolean']>;
  isHidden?: InputMaybe<Scalars['Boolean']>;
  visibility?: InputMaybe<VisibilityTypes>;
  isTitle?: InputMaybe<Scalars['Boolean']>;
  position?: InputMaybe<Scalars['Int']>;
  initialValue?: InputMaybe<Scalars['String']>;
  migrationValue?: InputMaybe<Scalars['String']>;
  isSystem?: InputMaybe<Scalars['Boolean']>;
};

/** Deleting enumarable field */
export type BatchMigrationDeleteEnumerationInput = {
  apiId: Scalars['String'];
};

/** Creating enumeration */
export type BatchMigrationCreateEnumerationInput = {
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  values: Array<BatchMigrationCreateEnumerationValueInput>;
  isSystem?: InputMaybe<Scalars['Boolean']>;
};

/** Updating enumeration */
export type BatchMigrationUpdateEnumerationInput = {
  apiId: Scalars['String'];
  newApiId?: InputMaybe<Scalars['String']>;
  displayName?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  valuesToCreate?: InputMaybe<Array<BatchMigrationCreateEnumerationValueInput>>;
  valuesToUpdate?: InputMaybe<Array<BatchMigrationUpdateEnumerationValueInput>>;
  valuesToDelete?: InputMaybe<Array<Scalars['String']>>;
  isSystem?: InputMaybe<Scalars['Boolean']>;
};

/** enumeration value */
export type BatchMigrationCreateEnumerationValueInput = {
  apiId: Scalars['String'];
  displayName: Scalars['String'];
};

/** update enumeration value */
export type BatchMigrationUpdateEnumerationValueInput = {
  apiId: Scalars['String'];
  newApiId?: InputMaybe<Scalars['String']>;
  displayName?: InputMaybe<Scalars['String']>;
};

/** Creating locale */
export type BatchMigrationCreateLocaleInput = {
  apiId: Scalars['String'];
  displayName: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
};

/** Updating locale */
export type BatchMigrationUpdateLocaleInput = {
  apiId: Scalars['String'];
  newApiId?: InputMaybe<Scalars['String']>;
  isDefault?: InputMaybe<Scalars['Boolean']>;
  displayName?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
};

/** Deleting locale */
export type BatchMigrationDeleteLocaleInput = {
  apiId: Scalars['String'];
  force?: InputMaybe<Scalars['Boolean']>;
};

export type BatchMigrationCreateGraphQlRemoteSourceInput = {
  displayName: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  /** Unique prefix that will be prepended to all of the remote types. This value cannot be changed! */
  prefix: Scalars['String'];
  url: Scalars['String'];
  headers?: InputMaybe<Scalars['JSON']>;
  /**
   * Specific URL that will be used for introspection if the introspection is available on another url than the regular url.
   * Can be ignored if the introspection url is the same as the url of the remote source.
   */
  introspectionUrl?: InputMaybe<Scalars['String']>;
  /** HTTP method that will be used for introspection */
  introspectionMethod: GraphQlRemoteSourceIntrospectionMethod;
  /** HTTP headers that will be used for introspection */
  introspectionHeaders?: InputMaybe<Scalars['JSON']>;
  /** Custom GraphQL input types that can be used as arguments in remote fields that belong to this remoteSource */
  remoteTypeDefinitions?: InputMaybe<BatchMigrationCreateRemoteTypeDefinitionInput>;
  debugEnabled?: InputMaybe<Scalars['Boolean']>;
  kind: RemoteSourceKind;
  /** Oauth input that can be used to get access token for the remote source */
  oAuth?: InputMaybe<RemoteSourceOAuthInput>;
};

export type BatchMigrationUpdateGraphQlRemoteSourceInput = {
  prefix: Scalars['String'];
  displayName?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  headers?: InputMaybe<Scalars['JSON']>;
  introspectionUrl?: InputMaybe<Scalars['String']>;
  introspectionMethod?: InputMaybe<GraphQlRemoteSourceIntrospectionMethod>;
  introspectionHeaders?: InputMaybe<Scalars['JSON']>;
  remoteTypeDefinitionsToUpsert?: InputMaybe<BatchMigrationUpsertRemoteTypeDefinitionsInput>;
  debugEnabled?: InputMaybe<Scalars['Boolean']>;
  kind?: InputMaybe<RemoteSourceKind>;
  /** Oauth input that can be used to get access token for the remote source */
  oAuth?: InputMaybe<RemoteSourceOAuthInput>;
};

export type BatchMigrationRefreshGraphQlRemoteSourceSchemaInput = {
  prefix: Scalars['String'];
};

export type BatchMigrationCreateRestRemoteSourceInput = {
  displayName: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  /** Unique prefix that will be prepended to all of the remote types. This value cannot be changed! */
  prefix: Scalars['String'];
  url: Scalars['String'];
  headers?: InputMaybe<Scalars['JSON']>;
  /** Remote type definitions that the remote source supports or input types that can be used by any remote field of this remote source */
  remoteTypeDefinitions?: InputMaybe<BatchMigrationCreateRemoteTypeDefinitionInput>;
  debugEnabled?: InputMaybe<Scalars['Boolean']>;
  kind: RemoteSourceKind;
  /** Oauth input that can be used to get access token for the remote source */
  oAuth?: InputMaybe<RemoteSourceOAuthInput>;
};

export type BatchMigrationUpdateRestRemoteSourceInput = {
  prefix: Scalars['String'];
  displayName: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  headers?: InputMaybe<Scalars['JSON']>;
  remoteTypeDefinitionsToUpsert?: InputMaybe<BatchMigrationUpsertRemoteTypeDefinitionsInput>;
  debugEnabled?: InputMaybe<Scalars['Boolean']>;
  kind?: InputMaybe<RemoteSourceKind>;
  /** Oauth input that can be used to get access token for the remote source */
  oAuth?: InputMaybe<RemoteSourceOAuthInput>;
};

export type BatchMigrationCreateRemoteTypeDefinitionInput = {
  sdl: Scalars['String'];
};

export type BatchMigrationDeleteRemoteSourceInput = {
  prefix: Scalars['String'];
};

export type BatchMigrationUpdateAppInstallationInput = {
  /** App Installation config, the object passed will be merged with the existing config */
  config?: InputMaybe<Scalars['JSON']>;
  /** App Installation status */
  status?: InputMaybe<AppInstallationStatus>;
};

/** Creating a custom sidebar element with app element */
export type BatchMigrationCreateCustomSidebarElementInput = {
  /** Api Id of the model associated with the custom sidebar element */
  modelApiId: Scalars['String'];
  /** Display name for the sidebar element */
  displayName: Scalars['String'];
  /** Description name for the sidebar element */
  description?: InputMaybe<Scalars['String']>;
  /** Json metadata associated with the sidebar element */
  config?: InputMaybe<Scalars['JSON']>;
  /** Api Id of the App element to create custom sidebar element with */
  appElementApiId: Scalars['String'];
  /** Api Id of the App */
  appApiId: Scalars['String'];
};

/** Deleting a custom sidebar element created by app element */
export type BatchMigrationDeleteCustomSidebarElementInput = {
  /** Api Id of the App */
  appApiId: Scalars['String'];
  /** Api Id of the App element associated with the custom sidebar element */
  appElementApiId: Scalars['String'];
  /** Api Id of the model associated with the custom sidebar element */
  modelApiId: Scalars['String'];
};

export type BatchMigrationCreateWebhookInput = {
  name: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  url: Scalars['String'];
  method?: InputMaybe<WebhookMethod>;
  headers?: InputMaybe<Scalars['JSON']>;
  isActive: Scalars['Boolean'];
  includePayload: Scalars['Boolean'];
  /**
   * Pass an empty array for all existing models.
   * This will also setup the webhook for models
   * created in the future
   */
  models: Array<Scalars['ID']>;
  /**
   * Pass an empty array for all existing stages.
   * This will also setup the webhook for stages
   * created in the future
   */
  stages: Array<Scalars['ID']>;
  triggerType: WebhookTriggerType;
  triggerActions: Array<WebhookTriggerAction>;
  secretKey?: InputMaybe<Scalars['String']>;
  triggerSources?: InputMaybe<Array<WebhookTriggerSource>>;
  isSystem?: InputMaybe<Scalars['Boolean']>;
};

export type BatchMigrationUpdateWebhookInput = {
  webhookId: Scalars['ID'];
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  headers?: InputMaybe<Scalars['JSON']>;
  url?: InputMaybe<Scalars['String']>;
  method?: InputMaybe<WebhookMethod>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  includePayload?: InputMaybe<Scalars['Boolean']>;
  stages?: InputMaybe<Array<Scalars['ID']>>;
  models?: InputMaybe<Array<Scalars['ID']>>;
  triggerType?: InputMaybe<WebhookTriggerType>;
  triggerActions?: InputMaybe<Array<WebhookTriggerAction>>;
  secretKey?: InputMaybe<Scalars['String']>;
  triggerSources?: InputMaybe<Array<WebhookTriggerSource>>;
  isSystem?: InputMaybe<Scalars['Boolean']>;
};

export type BatchMigrationDeleteWebhookInput = {
  webhookId: Scalars['ID'];
};

export type BatchMigrationChangeInput = {
  /** creates a new model */
  createModel?: InputMaybe<BatchMigrationCreateModelInput>;
  updateModel?: InputMaybe<BatchMigrationUpdateModelInput>;
  deleteModel?: InputMaybe<BatchMigrationDeleteModelInput>;
  createComponent?: InputMaybe<BatchMigrationCreateComponentInput>;
  updateComponent?: InputMaybe<BatchMigrationUpdateComponentInput>;
  deleteComponent?: InputMaybe<BatchMigrationDeleteComponentInput>;
  createSimpleField?: InputMaybe<BatchMigrationCreateSimpleFieldInput>;
  updateSimpleField?: InputMaybe<BatchMigrationUpdateSimpleFieldInput>;
  createRemoteField?: InputMaybe<BatchMigrationCreateRemoteFieldInput>;
  updateRemoteField?: InputMaybe<BatchMigrationUpdateRemoteFieldInput>;
  createRelationalField?: InputMaybe<BatchMigrationCreateRelationalFieldInput>;
  updateRelationalField?: InputMaybe<BatchMigrationUpdateRelationalFieldInput>;
  createUnionField?: InputMaybe<BatchMigrationCreateUnionFieldInput>;
  updateUnionField?: InputMaybe<BatchMigrationUpdateUnionFieldInput>;
  createComponentField?: InputMaybe<BatchMigrationCreateComponentFieldInput>;
  updateComponentField?: InputMaybe<BatchMigrationUpdateComponentFieldInput>;
  createComponentUnionField?: InputMaybe<BatchMigrationCreateComponentUnionFieldInput>;
  updateComponentUnionField?: InputMaybe<BatchMigrationUpdateComponentUnionFieldInput>;
  createEnumerableField?: InputMaybe<BatchMigrationCreateEnumerableFieldInput>;
  updateEnumerableField?: InputMaybe<BatchMigrationUpdateEnumerableFieldInput>;
  deleteField?: InputMaybe<BatchMigrationDeleteFieldInput>;
  createCustomSidebarElement?: InputMaybe<BatchMigrationCreateCustomSidebarElementInput>;
  deleteCustomSidebarElement?: InputMaybe<BatchMigrationDeleteCustomSidebarElementInput>;
  createEnumeration?: InputMaybe<BatchMigrationCreateEnumerationInput>;
  updateEnumeration?: InputMaybe<BatchMigrationUpdateEnumerationInput>;
  deleteEnumeration?: InputMaybe<BatchMigrationDeleteEnumerationInput>;
  createStage?: InputMaybe<BatchMigrationCreateStageInput>;
  deleteStage?: InputMaybe<BatchMigrationDeleteStageInput>;
  updateStage?: InputMaybe<BatchMigrationUpdateStageInput>;
  createLocale?: InputMaybe<BatchMigrationCreateLocaleInput>;
  deleteLocale?: InputMaybe<BatchMigrationDeleteLocaleInput>;
  updateLocale?: InputMaybe<BatchMigrationUpdateLocaleInput>;
  createGraphQLRemoteSource?: InputMaybe<BatchMigrationCreateGraphQlRemoteSourceInput>;
  updateGraphQLRemoteSource?: InputMaybe<BatchMigrationUpdateGraphQlRemoteSourceInput>;
  refreshGraphQLRemoteSourceSchema?: InputMaybe<BatchMigrationRefreshGraphQlRemoteSourceSchemaInput>;
  createRESTRemoteSource?: InputMaybe<BatchMigrationCreateRestRemoteSourceInput>;
  updateRESTRemoteSource?: InputMaybe<BatchMigrationUpdateRestRemoteSourceInput>;
  deleteRemoteSource?: InputMaybe<BatchMigrationDeleteRemoteSourceInput>;
  /** updates config and status for an AppInstallation, only valid for App Token bearer */
  updateAppInstallation?: InputMaybe<BatchMigrationUpdateAppInstallationInput>;
  /** creates a webhook */
  createWebhook?: InputMaybe<BatchMigrationCreateWebhookInput>;
  /** updates a webhook */
  updateWebhook?: InputMaybe<BatchMigrationUpdateWebhookInput>;
  /** deletes a webhook */
  deleteWebhook?: InputMaybe<BatchMigrationDeleteWebhookInput>;
};

export type DiffEnvironmentPayload = {
  __typename?: 'DiffEnvironmentPayload';
  changes: Array<Scalars['JSON']>;
};

export type BatchMigrationInput = {
  environmentId: Scalars['ID'];
  name?: InputMaybe<Scalars['String']>;
  changes: Array<BatchMigrationChangeInput>;
};

export type BatchMigrationUpsertRemoteTypeDefinitionsInput = {
  remoteTypeDefinitionsToCreate?: InputMaybe<Array<BatchMigrationUpsertRemoteTypeDefinitionToCreateInput>>;
  remoteTypeDefinitionsToDelete?: InputMaybe<Array<BatchMigrationUpsertRemoteTypeDefinitionToDeleteInput>>;
  remoteTypeDefinitionsToUpdate?: InputMaybe<Array<BatchMigrationUpsertRemoteTypeDefinitionToUpdateInput>>;
};

export type BatchMigrationUpsertRemoteTypeDefinitionToCreateInput = {
  sdl: Scalars['String'];
};

export type BatchMigrationUpsertRemoteTypeDefinitionToDeleteInput = {
  apiId: Scalars['String'];
};

export type BatchMigrationUpsertRemoteTypeDefinitionToUpdateInput = {
  apiId: Scalars['String'];
  sdl?: InputMaybe<Scalars['String']>;
};

export enum RemoteSourceType {
  Graphql = 'GRAPHQL',
  Rest = 'REST'
}

export enum RemoteSourceKind {
  CommerceTools = 'CommerceTools',
  CommerceLayer = 'CommerceLayer',
  Custom = 'Custom'
}

export enum OAuthGrantType {
  ClientCredentials = 'client_credentials'
}

export type RemoteSourceOAuthInput = {
  clientId: Scalars['String'];
  clientSecret?: InputMaybe<Scalars['String']>;
  scopes?: InputMaybe<Array<Scalars['String']>>;
  authorizationGrantType: OAuthGrantType;
  authorizationUrl: Scalars['String'];
};

export type Mutation = {
  __typename?: 'Mutation';
  submitBatchChanges: AsyncOperationPayload;
};


export type MutationSubmitBatchChangesArgs = {
  data: BatchMigrationInput;
};

export enum MigrationOperationType {
  CreateProjectFromTemplate = 'CREATE_PROJECT_FROM_TEMPLATE',
  CreateEnvironment = 'CREATE_ENVIRONMENT',
  Batch = 'BATCH',
  CreateStage = 'CREATE_STAGE',
  UpdateStage = 'UPDATE_STAGE',
  DeleteStage = 'DELETE_STAGE',
  CreateLocale = 'CREATE_LOCALE',
  UpdateLocale = 'UPDATE_LOCALE',
  DeleteLocale = 'DELETE_LOCALE',
  CreateModel = 'CREATE_MODEL',
  UpdateModel = 'UPDATE_MODEL',
  DeleteModel = 'DELETE_MODEL',
  CreateRemoteTypeDefinition = 'CREATE_REMOTE_TYPE_DEFINITION',
  UpdateRemoteTypeDefinition = 'UPDATE_REMOTE_TYPE_DEFINITION',
  DeleteRemoteTypeDefinition = 'DELETE_REMOTE_TYPE_DEFINITION',
  CreateEnumeration = 'CREATE_ENUMERATION',
  UpdateEnumeration = 'UPDATE_ENUMERATION',
  DeleteEnumeration = 'DELETE_ENUMERATION',
  CreateSimpleField = 'CREATE_SIMPLE_FIELD',
  CreateEnumerableField = 'CREATE_ENUMERABLE_FIELD',
  CreateRelationalField = 'CREATE_RELATIONAL_FIELD',
  CreateUnionField = 'CREATE_UNION_FIELD',
  CreateRemoteField = 'CREATE_REMOTE_FIELD',
  UpdateSimpleField = 'UPDATE_SIMPLE_FIELD',
  UpdateEnumerableField = 'UPDATE_ENUMERABLE_FIELD',
  UpdateRelationalField = 'UPDATE_RELATIONAL_FIELD',
  UpdateUnionField = 'UPDATE_UNION_FIELD',
  DeleteField = 'DELETE_FIELD'
}

export enum NetlifyBuildState {
  Ready = 'READY',
  Preparing = 'PREPARING',
  Building = 'BUILDING',
  Failed = 'FAILED'
}

export type UserSelection = {
  __typename?: 'UserSelection';
  id: Scalars['ID'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
  selection: Scalars['JSON'];
};
